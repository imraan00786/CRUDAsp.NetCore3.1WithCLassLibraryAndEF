{"version":3,"sources":["webpack:///./node_modules/aurelia-templating-router/dist/native-modules/aurelia-templating-router.js"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAgE;AACtB;AACI;AAC4I;AACjI;AACD;AACtB;AACU;;AAE5C;AACA;AACA,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+CAAG,UAAU,sEAAS,EAAE,2DAAQ,EAAE,qDAAM,EAAE,8DAAW,EAAE,yEAAsB,EAAE,oEAAiB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iGAAiG;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,uDAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,sEAAmB;AAC1E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,iEAAc,qBAAqB,iEAAc;AAChF;AACA,8DAA8D,kDAAkD,EAAE;AAClH;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAS;AACzB;AACA;AACA,0CAA0C,6EAAqB;AAC/D;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,gCAAgC,EAAE;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,6DAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mEAAc,WAAW,uDAAM;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,qDAAM,eAAe,0EAA0E,EAAE;AAC5I,sCAAsC,qDAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,SAAS,EAAE,EAAE;AACb;AACA;AACA,oCAAoC,oEAAiB;AACrD;AACA,CAAC,CAAC,0DAAW;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,wEAAa;AACjB,IAAI,kEAAO;AACX;AACA;;AAEA,aAAa,iEAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qDAAM,EAAE,+CAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,uEAAuE;AACpF,aAAa,iDAAiD;AAC9D;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA,mBAAmB,0DAAW;AAC9B,mBAAmB,qDAAM,EAAE,wDAAS;AACpC;AACA,mCAAmC,qDAAM,EAAE,wDAAS;AACpD;;AAEmE;AACnE","file":"npm.aurelia-templating-router.dfb9ffe44f096120d050.js","sourcesContent":["import { Router, RouteLoader, AppRouter } from 'aurelia-router';\nimport { Origin } from 'aurelia-metadata';\nimport { relativeToFile } from 'aurelia-path';\nimport { BehaviorInstruction, ShadowDOM, ViewSlot, ViewLocator, CompositionTransaction, CompositionEngine, SwapStrategies, inlineView, customElement, useView } from 'aurelia-templating';\nimport { Container } from 'aurelia-dependency-injection';\nimport { createOverrideContext } from 'aurelia-binding';\nimport { DOM } from 'aurelia-pal';\nimport { getLogger } from 'aurelia-logging';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\nvar EmptyLayoutViewModel = /** @class */ (function () {\r\n    function EmptyLayoutViewModel() {\r\n    }\r\n    return EmptyLayoutViewModel;\r\n}());\r\n/**\r\n * Implementation of Aurelia Router ViewPort. Responsible for loading route, composing and swapping routes views\r\n */\r\nvar RouterView = /** @class */ (function () {\r\n    function RouterView(element, container, viewSlot, router, viewLocator, compositionTransaction, compositionEngine) {\r\n        this.element = element;\r\n        this.container = container;\r\n        this.viewSlot = viewSlot;\r\n        this.router = router;\r\n        this.viewLocator = viewLocator;\r\n        this.compositionTransaction = compositionTransaction;\r\n        this.compositionEngine = compositionEngine;\r\n        // add this <router-view/> to router view ports lookup based on name attribute\r\n        // when this router is the root router-view\r\n        // also trigger AppRouter registerViewPort extra flow\r\n        this.router.registerViewPort(this, this.element.getAttribute('name'));\r\n        // Each <router-view/> process its instruction as a composition transaction\r\n        // there are differences between intial composition and subsequent compositions\r\n        // also there are differences between root composition and child <router-view/> composition\r\n        // mark the first composition transaction with a property initialComposition to distinguish it\r\n        // when the root <router-view/> gets new instruction for the first time\r\n        if (!('initialComposition' in compositionTransaction)) {\r\n            compositionTransaction.initialComposition = true;\r\n            this.compositionTransactionNotifier = compositionTransaction.enlist();\r\n        }\r\n    }\r\n    /**@internal */\r\n    RouterView.inject = function () {\r\n        return [DOM.Element, Container, ViewSlot, Router, ViewLocator, CompositionTransaction, CompositionEngine];\r\n    };\r\n    RouterView.prototype.created = function (owningView) {\r\n        this.owningView = owningView;\r\n    };\r\n    RouterView.prototype.bind = function (bindingContext, overrideContext) {\r\n        // router needs to get access to view model of current route parent\r\n        // doing it in generic way via viewModel property on container\r\n        this.container.viewModel = bindingContext;\r\n        this.overrideContext = overrideContext;\r\n    };\r\n    /**\r\n     * Implementation of `aurelia-router` ViewPort interface, responsible for templating related part in routing Pipeline\r\n     */\r\n    RouterView.prototype.process = function ($viewPortInstruction, waitToSwap) {\r\n        var _this = this;\r\n        // have strong typings without exposing it in public typings, this is to ensure maximum backward compat\r\n        var viewPortInstruction = $viewPortInstruction;\r\n        var component = viewPortInstruction.component;\r\n        var childContainer = component.childContainer;\r\n        var viewModel = component.viewModel;\r\n        var viewModelResource = component.viewModelResource;\r\n        var metadata = viewModelResource.metadata;\r\n        var config = component.router.currentInstruction.config;\r\n        var viewPortConfig = config.viewPorts ? (config.viewPorts[viewPortInstruction.name] || {}) : {};\r\n        childContainer.get(RouterViewLocator)._notify(this);\r\n        // layoutInstruction is our layout viewModel\r\n        var layoutInstruction = {\r\n            viewModel: viewPortConfig.layoutViewModel || config.layoutViewModel || this.layoutViewModel,\r\n            view: viewPortConfig.layoutView || config.layoutView || this.layoutView,\r\n            model: viewPortConfig.layoutModel || config.layoutModel || this.layoutModel,\r\n            router: viewPortInstruction.component.router,\r\n            childContainer: childContainer,\r\n            viewSlot: this.viewSlot\r\n        };\r\n        // viewport will be a thin wrapper around composition engine\r\n        // to process instruction/configuration from users\r\n        // preparing all information related to a composition process\r\n        // first by getting view strategy of a ViewPortComponent View\r\n        var viewStrategy = this.viewLocator.getViewStrategy(component.view || viewModel);\r\n        if (viewStrategy && component.view) {\r\n            viewStrategy.makeRelativeTo(Origin.get(component.router.container.viewModel.constructor).moduleId);\r\n        }\r\n        // using metadata of a custom element view model to load appropriate view-factory instance\r\n        return metadata\r\n            .load(childContainer, viewModelResource.value, null, viewStrategy, true)\r\n            // for custom element, viewFactory typing is always ViewFactory\r\n            // for custom attribute, it will be HtmlBehaviorResource\r\n            .then(function (viewFactory) {\r\n            // if this is not the first time that this <router-view/> is composing its instruction\r\n            // try to capture ownership of the composition transaction\r\n            // child <router-view/> will not be able to capture, since root <router-view/> typically captures\r\n            // the ownership token\r\n            if (!_this.compositionTransactionNotifier) {\r\n                _this.compositionTransactionOwnershipToken = _this.compositionTransaction.tryCapture();\r\n            }\r\n            if (layoutInstruction.viewModel || layoutInstruction.view) {\r\n                viewPortInstruction.layoutInstruction = layoutInstruction;\r\n            }\r\n            var viewPortComponentBehaviorInstruction = BehaviorInstruction.dynamic(_this.element, viewModel, viewFactory);\r\n            viewPortInstruction.controller = metadata.create(childContainer, viewPortComponentBehaviorInstruction);\r\n            if (waitToSwap) {\r\n                return null;\r\n            }\r\n            _this.swap(viewPortInstruction);\r\n        });\r\n    };\r\n    RouterView.prototype.swap = function ($viewPortInstruction) {\r\n        var _this = this;\r\n        // have strong typings without exposing it in public typings, this is to ensure maximum backward compat\r\n        var viewPortInstruction = $viewPortInstruction;\r\n        var viewPortController = viewPortInstruction.controller;\r\n        var layoutInstruction = viewPortInstruction.layoutInstruction;\r\n        var previousView = this.view;\r\n        // Final step of swapping a <router-view/> ViewPortComponent\r\n        var work = function () {\r\n            var swapStrategy = SwapStrategies[_this.swapOrder] || SwapStrategies.after;\r\n            var viewSlot = _this.viewSlot;\r\n            swapStrategy(viewSlot, previousView, function () { return Promise.resolve(viewSlot.add(_this.view)); }).then(function () {\r\n                _this._notify();\r\n            });\r\n        };\r\n        // Ensure all users setups have been completed\r\n        var ready = function (owningView_or_layoutView) {\r\n            viewPortController.automate(_this.overrideContext, owningView_or_layoutView);\r\n            var transactionOwnerShipToken = _this.compositionTransactionOwnershipToken;\r\n            // if this router-view is the root <router-view/> of a normal startup via aurelia.setRoot\r\n            // attemp to take control of the transaction\r\n            // if ownership can be taken\r\n            // wait for transaction to complete before swapping\r\n            if (transactionOwnerShipToken) {\r\n                return transactionOwnerShipToken\r\n                    .waitForCompositionComplete()\r\n                    .then(function () {\r\n                    _this.compositionTransactionOwnershipToken = null;\r\n                    return work();\r\n                });\r\n            }\r\n            // otherwise, just swap\r\n            return work();\r\n        };\r\n        // If there is layout instruction, new to compose layout before processing ViewPortComponent\r\n        // layout controller/view/view-model is composed using composition engine APIs\r\n        if (layoutInstruction) {\r\n            if (!layoutInstruction.viewModel) {\r\n                // createController chokes if there's no viewmodel, so create a dummy one\r\n                // but avoid using a POJO as it creates unwanted metadata in Object constructor\r\n                layoutInstruction.viewModel = new EmptyLayoutViewModel();\r\n            }\r\n            // using composition engine to create compose layout\r\n            return this.compositionEngine\r\n                // first create controller from layoutInstruction\r\n                // and treat it as CompositionContext\r\n                // then emulate slot projection with ViewPortComponent view\r\n                .createController(layoutInstruction)\r\n                .then(function (layoutController) {\r\n                var layoutView = layoutController.view;\r\n                ShadowDOM.distributeView(viewPortController.view, layoutController.slots || layoutView.slots);\r\n                // when there is a layout\r\n                // view hierarchy is: <router-view/> owner view -> layout view -> ViewPortComponent view\r\n                layoutController.automate(createOverrideContext(layoutInstruction.viewModel), _this.owningView);\r\n                layoutView.children.push(viewPortController.view);\r\n                return layoutView || layoutController;\r\n            })\r\n                .then(function (newView) {\r\n                _this.view = newView;\r\n                return ready(newView);\r\n            });\r\n        }\r\n        // if there is no layout, then get ViewPortComponent view ready as view property\r\n        // and process controller/swapping\r\n        // when there is no layout\r\n        // view hierarchy is: <router-view/> owner view -> ViewPortComponent view\r\n        this.view = viewPortController.view;\r\n        return ready(this.owningView);\r\n    };\r\n    /**\r\n     * Notify composition transaction that this router has finished processing\r\n     * Happens when this <router-view/> is the root router-view\r\n     * @internal\r\n     */\r\n    RouterView.prototype._notify = function () {\r\n        var notifier = this.compositionTransactionNotifier;\r\n        if (notifier) {\r\n            notifier.done();\r\n            this.compositionTransactionNotifier = null;\r\n        }\r\n    };\r\n    /**\r\n     * @internal Actively avoid using decorator to reduce the amount of code generated\r\n     *\r\n     * There is no view to compose by default in a router view\r\n     * This custom element is responsible for composing its own view, based on current config\r\n     */\r\n    RouterView.$view = null;\r\n    /**\r\n     * @internal Actively avoid using decorator to reduce the amount of code generated\r\n     */\r\n    RouterView.$resource = {\r\n        name: 'router-view',\r\n        bindables: ['swapOrder', 'layoutView', 'layoutViewModel', 'layoutModel', 'inherit-binding-context']\r\n    };\r\n    return RouterView;\r\n}());\r\n/**\r\n* Locator which finds the nearest RouterView, relative to the current dependency injection container.\r\n*/\r\nvar RouterViewLocator = /** @class */ (function () {\r\n    /**\r\n    * Creates an instance of the RouterViewLocator class.\r\n    */\r\n    function RouterViewLocator() {\r\n        var _this = this;\r\n        this.promise = new Promise(function (resolve) { return _this.resolve = resolve; });\r\n    }\r\n    /**\r\n    * Finds the nearest RouterView instance.\r\n    * @returns A promise that will be resolved with the located RouterView instance.\r\n    */\r\n    RouterViewLocator.prototype.findNearest = function () {\r\n        return this.promise;\r\n    };\r\n    /**@internal */\r\n    RouterViewLocator.prototype._notify = function (routerView) {\r\n        this.resolve(routerView);\r\n    };\r\n    return RouterViewLocator;\r\n}());\n\n/**@internal exported for unit testing */\r\nvar EmptyClass = /** @class */ (function () {\r\n    function EmptyClass() {\r\n    }\r\n    return EmptyClass;\r\n}());\r\ninlineView('<template></template>')(EmptyClass);\r\n/**\r\n * Default implementation of `RouteLoader` used for loading component based on a route config\r\n */\r\nvar TemplatingRouteLoader = /** @class */ (function (_super) {\r\n    __extends(TemplatingRouteLoader, _super);\r\n    function TemplatingRouteLoader(compositionEngine) {\r\n        var _this = _super.call(this) || this;\r\n        _this.compositionEngine = compositionEngine;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Resolve a view model from a RouteConfig\r\n     * Throws when there is neither \"moduleId\" nor \"viewModel\" property\r\n     * @internal\r\n     */\r\n    TemplatingRouteLoader.prototype.resolveViewModel = function (router, config) {\r\n        return new Promise(function (resolve, reject) {\r\n            var viewModel;\r\n            if ('moduleId' in config) {\r\n                var moduleId = config.moduleId;\r\n                if (moduleId === null) {\r\n                    viewModel = EmptyClass;\r\n                }\r\n                else {\r\n                    // this requires container of router has passes a certain point\r\n                    // where a view model has been setup on the container\r\n                    // it will fail in enhance scenario because no viewport has been registered\r\n                    moduleId = relativeToFile(moduleId, Origin.get(router.container.viewModel.constructor).moduleId);\r\n                    if (/\\.html/i.test(moduleId)) {\r\n                        viewModel = createDynamicClass(moduleId);\r\n                    }\r\n                    else {\r\n                        viewModel = moduleId;\r\n                    }\r\n                }\r\n                return resolve(viewModel);\r\n            }\r\n            // todo: add if ('viewModel' in config) to support static view model resolution\r\n            reject(new Error('Invalid route config. No \"moduleId\" found.'));\r\n        });\r\n    };\r\n    /**\r\n     * Create child container based on a router container\r\n     * Also ensures that child router are properly constructed in the newly created child container\r\n     * @internal\r\n     */\r\n    TemplatingRouteLoader.prototype.createChildContainer = function (router) {\r\n        var childContainer = router.container.createChild();\r\n        childContainer.registerSingleton(RouterViewLocator);\r\n        childContainer.getChildRouter = function () {\r\n            var childRouter;\r\n            childContainer.registerHandler(Router, function () { return childRouter || (childRouter = router.createChild(childContainer)); });\r\n            return childContainer.get(Router);\r\n        };\r\n        return childContainer;\r\n    };\r\n    /**\r\n     * Load corresponding component of a route config of a navigation instruction\r\n     */\r\n    TemplatingRouteLoader.prototype.loadRoute = function (router, config, _navInstruction) {\r\n        var _this = this;\r\n        return this\r\n            .resolveViewModel(router, config)\r\n            .then(function (viewModel) { return _this.compositionEngine.ensureViewModel({\r\n            viewModel: viewModel,\r\n            childContainer: _this.createChildContainer(router),\r\n            view: config.view || config.viewStrategy,\r\n            router: router\r\n        }); });\r\n    };\r\n    /**@internal */\r\n    TemplatingRouteLoader.inject = [CompositionEngine];\r\n    return TemplatingRouteLoader;\r\n}(RouteLoader));\r\n/**@internal exported for unit testing */\r\nfunction createDynamicClass(moduleId) {\r\n    var name = /([^\\/^\\?]+)\\.html/i.exec(moduleId)[1];\r\n    var DynamicClass = /** @class */ (function () {\r\n        function DynamicClass() {\r\n        }\r\n        DynamicClass.prototype.bind = function (bindingContext) {\r\n            this.$parent = bindingContext;\r\n        };\r\n        return DynamicClass;\r\n    }());\r\n    customElement(name)(DynamicClass);\r\n    useView(moduleId)(DynamicClass);\r\n    return DynamicClass;\r\n}\n\nvar logger = getLogger('route-href');\r\n/**\r\n * Helper custom attribute to help associate an element with a route by name\r\n */\r\nvar RouteHref = /** @class */ (function () {\r\n    function RouteHref(router, element) {\r\n        this.router = router;\r\n        this.element = element;\r\n        this.attribute = 'href';\r\n    }\r\n    /*@internal */\r\n    RouteHref.inject = function () {\r\n        return [Router, DOM.Element];\r\n    };\r\n    RouteHref.prototype.bind = function () {\r\n        this.isActive = true;\r\n        this.processChange();\r\n    };\r\n    RouteHref.prototype.unbind = function () {\r\n        this.isActive = false;\r\n    };\r\n    RouteHref.prototype.attributeChanged = function (value, previous) {\r\n        if (previous) {\r\n            this.element.removeAttribute(previous);\r\n        }\r\n        return this.processChange();\r\n    };\r\n    RouteHref.prototype.processChange = function () {\r\n        var _this = this;\r\n        return this.router\r\n            .ensureConfigured()\r\n            .then(function () {\r\n            if (!_this.isActive) {\r\n                // returning null to avoid Bluebird warning\r\n                return null;\r\n            }\r\n            var element = _this.element;\r\n            var href = _this.router.generate(_this.route, _this.params);\r\n            if (element.au.controller) {\r\n                element.au.controller.viewModel[_this.attribute] = href;\r\n            }\r\n            else {\r\n                element.setAttribute(_this.attribute, href);\r\n            }\r\n            // returning null to avoid Bluebird warning\r\n            return null;\r\n        })\r\n            .catch(function (reason) {\r\n            logger.error(reason);\r\n        });\r\n    };\r\n    /**\r\n     * @internal Actively avoid using decorator to reduce the amount of code generated\r\n     */\r\n    RouteHref.$resource = {\r\n        type: 'attribute',\r\n        name: 'route-href',\r\n        bindables: [\r\n            { name: 'route', changeHandler: 'processChange', primaryProperty: true },\r\n            { name: 'params', changeHandler: 'processChange' },\r\n            'attribute'\r\n        ] // type definition of Aurelia templating is wrong\r\n    };\r\n    return RouteHref;\r\n}());\n\nfunction configure(config) {\r\n    config\r\n        .singleton(RouteLoader, TemplatingRouteLoader)\r\n        .singleton(Router, AppRouter)\r\n        .globalResources(RouterView, RouteHref);\r\n    config.container.registerAlias(Router, AppRouter);\r\n}\n\nexport { RouteHref, RouterView, TemplatingRouteLoader, configure };\n//# sourceMappingURL=aurelia-templating-router.js.map\n"],"sourceRoot":""}