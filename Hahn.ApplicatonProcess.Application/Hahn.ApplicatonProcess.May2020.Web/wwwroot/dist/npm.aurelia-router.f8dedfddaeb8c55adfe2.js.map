{"version":3,"sources":["webpack:///./node_modules/aurelia-router/dist/native-modules/aurelia-router.js"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4C;AACa;AACf;AACiB;AACA;;AAE3D;AACA;AACA,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,gBAAgB,sCAAsC,iBAAiB,EAAE;AACnF,yBAAyB,uDAAuD;AAChF;AACA;;AAEA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,8BAA8B,EAAE,uBAAuB,UAAU,EAAE;AAC9H;AACA;AACA;AACA;AACA;AACA,qCAAqC,qBAAqB,gCAAgC;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,+DAA+D;AACxG;AACA;AACA;AACA,2CAA2C;AAC3C;AACA,4CAA4C,EAAE;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,+CAA+C,EAAE;AAC9F;AACA,SAAS;AACT,+BAA+B,qBAAqB,EAAE;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,mBAAmB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA,8BAA8B,kBAAkB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,yBAAyB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,qBAAqB,EAAE;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,gBAAgB,WAAW,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,QAAQ;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,QAAQ;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,wEAAe;AAC9C,oCAAoC,wEAAe;AACnD;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF;AACtF,iBAAiB,OAAO;AACxB;AACA;AACA,gCAAgC,aAAa;AAC7C,iCAAiC,cAAc;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,0BAA0B,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,UAAU;AACvC,2CAA2C,0BAA0B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE;AACxE,yBAAyB,iBAAiB;AAC1C,+FAA+F;AAC/F;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E,6BAA6B,iBAAiB;AAC9C,mGAAmG;AACnG;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,gCAAgC,iCAAiC,cAAc,KAAK,EAAE;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,KAAK,EAAE;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,OAAO;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,cAAc;AAC/C;AACA,sCAAsC,+BAA+B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,aAAa;AAC7C,iCAAiC,cAAc;AAC/C;AACA;AACA,sCAAsC,+BAA+B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,sBAAsB,EAAE;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,gEAAgE,4FAA4F,EAAE;AAC9J;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,mBAAmB;AACrD;AACA;AACA;AACA;AACA;AACA,+BAA+B,2EAA2E;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qEAAqE,EAAE;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,0GAA0G,EAAE;AACrJ,mCAAmC,kBAAkB,EAAE;AACvD;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,sBAAsB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gEAAgE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE,uCAAuC,EAAE;AACzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,WAAW;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,EAAE,EAAE;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+BAA+B,EAAE;AAC7E;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS,sEAAS,EAAE;AAC/D;AACA;AACA;AACA;AACA;AACA,8CAA8C,6BAA6B;AAC3E;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,6CAA6C,oDAAoD,EAAE;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,WAAW;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA,aAAa,iEAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS,sEAAS,EAAE,uDAAO,oBAAoB,wEAAe,EAAE;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,6CAA6C,EAAE;AACzF;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe,EAAE;AAChE,qBAAqB;AACrB;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,wCAAwC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uFAAuF,2BAA2B;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,oEAAoE,EAAE;AAC/G;AACA,wBAAwB;AACxB,aAAa;AACb,yCAAyC,2EAA2E,EAAE;AACtH,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAyD,EAAE;AACvF,sCAAsC,6CAA6C,EAAE;AACrF;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,gCAAgC;AAC3E;AACA;AACA,+CAA+C,+BAA+B;AAC9E;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;;AAEuV;AACpY","file":"npm.aurelia-router.f8dedfddaeb8c55adfe2.js","sourcesContent":["import { getLogger } from 'aurelia-logging';\nimport { Container } from 'aurelia-dependency-injection';\nimport { History } from 'aurelia-history';\nimport { RouteRecognizer } from 'aurelia-route-recognizer';\nimport { EventAggregator } from 'aurelia-event-aggregator';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\n\n/**\r\n * Class used to represent an instruction during a navigation.\r\n */\r\nvar NavigationInstruction = /** @class */ (function () {\r\n    function NavigationInstruction(init) {\r\n        /**\r\n         * Current built viewport plan of this nav instruction\r\n         */\r\n        this.plan = null;\r\n        this.options = {};\r\n        Object.assign(this, init);\r\n        this.params = this.params || {};\r\n        this.viewPortInstructions = {};\r\n        var ancestorParams = [];\r\n        var current = this;\r\n        do {\r\n            var currentParams = Object.assign({}, current.params);\r\n            if (current.config && current.config.hasChildRouter) {\r\n                // remove the param for the injected child route segment\r\n                delete currentParams[current.getWildCardName()];\r\n            }\r\n            ancestorParams.unshift(currentParams);\r\n            current = current.parentInstruction;\r\n        } while (current);\r\n        var allParams = Object.assign.apply(Object, [{}, this.queryParams].concat(ancestorParams));\r\n        this.lifecycleArgs = [allParams, this.config, this];\r\n    }\r\n    /**\r\n     * Gets an array containing this instruction and all child instructions for the current navigation.\r\n     */\r\n    NavigationInstruction.prototype.getAllInstructions = function () {\r\n        var instructions = [this];\r\n        var viewPortInstructions = this.viewPortInstructions;\r\n        for (var key in viewPortInstructions) {\r\n            var childInstruction = viewPortInstructions[key].childNavigationInstruction;\r\n            if (childInstruction) {\r\n                instructions.push.apply(instructions, childInstruction.getAllInstructions());\r\n            }\r\n        }\r\n        return instructions;\r\n    };\r\n    /**\r\n     * Gets an array containing the instruction and all child instructions for the previous navigation.\r\n     * Previous instructions are no longer available after navigation completes.\r\n     */\r\n    NavigationInstruction.prototype.getAllPreviousInstructions = function () {\r\n        return this.getAllInstructions().map(function (c) { return c.previousInstruction; }).filter(function (c) { return c; });\r\n    };\r\n    NavigationInstruction.prototype.addViewPortInstruction = function (nameOrInitOptions, strategy, moduleId, component) {\r\n        var viewPortInstruction;\r\n        var viewPortName = typeof nameOrInitOptions === 'string' ? nameOrInitOptions : nameOrInitOptions.name;\r\n        var lifecycleArgs = this.lifecycleArgs;\r\n        var config = Object.assign({}, lifecycleArgs[1], { currentViewPort: viewPortName });\r\n        if (typeof nameOrInitOptions === 'string') {\r\n            viewPortInstruction = {\r\n                name: nameOrInitOptions,\r\n                strategy: strategy,\r\n                moduleId: moduleId,\r\n                component: component,\r\n                childRouter: component.childRouter,\r\n                lifecycleArgs: [lifecycleArgs[0], config, lifecycleArgs[2]]\r\n            };\r\n        }\r\n        else {\r\n            viewPortInstruction = {\r\n                name: viewPortName,\r\n                strategy: nameOrInitOptions.strategy,\r\n                component: nameOrInitOptions.component,\r\n                moduleId: nameOrInitOptions.moduleId,\r\n                childRouter: nameOrInitOptions.component.childRouter,\r\n                lifecycleArgs: [lifecycleArgs[0], config, lifecycleArgs[2]]\r\n            };\r\n        }\r\n        return this.viewPortInstructions[viewPortName] = viewPortInstruction;\r\n    };\r\n    /**\r\n     * Gets the name of the route pattern's wildcard parameter, if applicable.\r\n     */\r\n    NavigationInstruction.prototype.getWildCardName = function () {\r\n        // todo: potential issue, or at least unsafe typings\r\n        var configRoute = this.config.route;\r\n        var wildcardIndex = configRoute.lastIndexOf('*');\r\n        return configRoute.substr(wildcardIndex + 1);\r\n    };\r\n    /**\r\n     * Gets the path and query string created by filling the route\r\n     * pattern's wildcard parameter with the matching param.\r\n     */\r\n    NavigationInstruction.prototype.getWildcardPath = function () {\r\n        var wildcardName = this.getWildCardName();\r\n        var path = this.params[wildcardName] || '';\r\n        var queryString = this.queryString;\r\n        if (queryString) {\r\n            path += '?' + queryString;\r\n        }\r\n        return path;\r\n    };\r\n    /**\r\n     * Gets the instruction's base URL, accounting for wildcard route parameters.\r\n     */\r\n    NavigationInstruction.prototype.getBaseUrl = function () {\r\n        var _this = this;\r\n        var $encodeURI = encodeURI;\r\n        var fragment = decodeURI(this.fragment);\r\n        if (fragment === '') {\r\n            var nonEmptyRoute = this.router.routes.find(function (route) {\r\n                return route.name === _this.config.name &&\r\n                    route.route !== '';\r\n            });\r\n            if (nonEmptyRoute) {\r\n                fragment = nonEmptyRoute.route;\r\n            }\r\n        }\r\n        if (!this.params) {\r\n            return $encodeURI(fragment);\r\n        }\r\n        var wildcardName = this.getWildCardName();\r\n        var path = this.params[wildcardName] || '';\r\n        if (!path) {\r\n            return $encodeURI(fragment);\r\n        }\r\n        return $encodeURI(fragment.substr(0, fragment.lastIndexOf(path)));\r\n    };\r\n    /**\r\n     * Finalize a viewport instruction\r\n     * @internal\r\n     */\r\n    NavigationInstruction.prototype._commitChanges = function (waitToSwap) {\r\n        var _this = this;\r\n        var router = this.router;\r\n        router.currentInstruction = this;\r\n        var previousInstruction = this.previousInstruction;\r\n        if (previousInstruction) {\r\n            previousInstruction.config.navModel.isActive = false;\r\n        }\r\n        this.config.navModel.isActive = true;\r\n        router.refreshNavigation();\r\n        var loads = [];\r\n        var delaySwaps = [];\r\n        var viewPortInstructions = this.viewPortInstructions;\r\n        var _loop_1 = function (viewPortName) {\r\n            var viewPortInstruction = viewPortInstructions[viewPortName];\r\n            var viewPort = router.viewPorts[viewPortName];\r\n            if (!viewPort) {\r\n                throw new Error(\"There was no router-view found in the view for \" + viewPortInstruction.moduleId + \".\");\r\n            }\r\n            var childNavInstruction = viewPortInstruction.childNavigationInstruction;\r\n            if (viewPortInstruction.strategy === \"replace\" /* Replace */) {\r\n                if (childNavInstruction && childNavInstruction.parentCatchHandler) {\r\n                    loads.push(childNavInstruction._commitChanges(waitToSwap));\r\n                }\r\n                else {\r\n                    if (waitToSwap) {\r\n                        delaySwaps.push({ viewPort: viewPort, viewPortInstruction: viewPortInstruction });\r\n                    }\r\n                    loads.push(viewPort\r\n                        .process(viewPortInstruction, waitToSwap)\r\n                        .then(function () { return childNavInstruction\r\n                        ? childNavInstruction._commitChanges(waitToSwap)\r\n                        : Promise.resolve(); }));\r\n                }\r\n            }\r\n            else {\r\n                if (childNavInstruction) {\r\n                    loads.push(childNavInstruction._commitChanges(waitToSwap));\r\n                }\r\n            }\r\n        };\r\n        for (var viewPortName in viewPortInstructions) {\r\n            _loop_1(viewPortName);\r\n        }\r\n        return Promise\r\n            .all(loads)\r\n            .then(function () {\r\n            delaySwaps.forEach(function (x) { return x.viewPort.swap(x.viewPortInstruction); });\r\n            return null;\r\n        })\r\n            .then(function () { return prune(_this); });\r\n    };\r\n    /**@internal */\r\n    NavigationInstruction.prototype._updateTitle = function () {\r\n        var router = this.router;\r\n        var title = this._buildTitle(router.titleSeparator);\r\n        if (title) {\r\n            router.history.setTitle(title);\r\n        }\r\n    };\r\n    /**@internal */\r\n    NavigationInstruction.prototype._buildTitle = function (separator) {\r\n        if (separator === void 0) { separator = ' | '; }\r\n        var title = '';\r\n        var childTitles = [];\r\n        var navModelTitle = this.config.navModel.title;\r\n        var instructionRouter = this.router;\r\n        var viewPortInstructions = this.viewPortInstructions;\r\n        if (navModelTitle) {\r\n            title = instructionRouter.transformTitle(navModelTitle);\r\n        }\r\n        for (var viewPortName in viewPortInstructions) {\r\n            var viewPortInstruction = viewPortInstructions[viewPortName];\r\n            var child_nav_instruction = viewPortInstruction.childNavigationInstruction;\r\n            if (child_nav_instruction) {\r\n                var childTitle = child_nav_instruction._buildTitle(separator);\r\n                if (childTitle) {\r\n                    childTitles.push(childTitle);\r\n                }\r\n            }\r\n        }\r\n        if (childTitles.length) {\r\n            title = childTitles.join(separator) + (title ? separator : '') + title;\r\n        }\r\n        if (instructionRouter.title) {\r\n            title += (title ? separator : '') + instructionRouter.transformTitle(instructionRouter.title);\r\n        }\r\n        return title;\r\n    };\r\n    return NavigationInstruction;\r\n}());\r\nvar prune = function (instruction) {\r\n    instruction.previousInstruction = null;\r\n    instruction.plan = null;\r\n};\n\n/**\r\n* Class for storing and interacting with a route's navigation settings.\r\n*/\r\nvar NavModel = /** @class */ (function () {\r\n    function NavModel(router, relativeHref) {\r\n        /**\r\n        * True if this nav item is currently active.\r\n        */\r\n        this.isActive = false;\r\n        /**\r\n        * The title.\r\n        */\r\n        this.title = null;\r\n        /**\r\n        * This nav item's absolute href.\r\n        */\r\n        this.href = null;\r\n        /**\r\n        * This nav item's relative href.\r\n        */\r\n        this.relativeHref = null;\r\n        /**\r\n        * Data attached to the route at configuration time.\r\n        */\r\n        this.settings = {};\r\n        /**\r\n        * The route config.\r\n        */\r\n        this.config = null;\r\n        this.router = router;\r\n        this.relativeHref = relativeHref;\r\n    }\r\n    /**\r\n    * Sets the route's title and updates document.title.\r\n    *  If the a navigation is in progress, the change will be applied\r\n    *  to document.title when the navigation completes.\r\n    *\r\n    * @param title The new title.\r\n    */\r\n    NavModel.prototype.setTitle = function (title) {\r\n        this.title = title;\r\n        if (this.isActive) {\r\n            this.router.updateTitle();\r\n        }\r\n    };\r\n    return NavModel;\r\n}());\n\nfunction _normalizeAbsolutePath(path, hasPushState, absolute) {\r\n    if (absolute === void 0) { absolute = false; }\r\n    if (!hasPushState && path[0] !== '#') {\r\n        path = '#' + path;\r\n    }\r\n    if (hasPushState && absolute) {\r\n        path = path.substring(1, path.length);\r\n    }\r\n    return path;\r\n}\r\nfunction _createRootedPath(fragment, baseUrl, hasPushState, absolute) {\r\n    if (isAbsoluteUrl.test(fragment)) {\r\n        return fragment;\r\n    }\r\n    var path = '';\r\n    if (baseUrl.length && baseUrl[0] !== '/') {\r\n        path += '/';\r\n    }\r\n    path += baseUrl;\r\n    if ((!path.length || path[path.length - 1] !== '/') && fragment[0] !== '/') {\r\n        path += '/';\r\n    }\r\n    if (path.length && path[path.length - 1] === '/' && fragment[0] === '/') {\r\n        path = path.substring(0, path.length - 1);\r\n    }\r\n    return _normalizeAbsolutePath(path + fragment, hasPushState, absolute);\r\n}\r\nfunction _resolveUrl(fragment, baseUrl, hasPushState) {\r\n    if (isRootedPath.test(fragment)) {\r\n        return _normalizeAbsolutePath(fragment, hasPushState);\r\n    }\r\n    return _createRootedPath(fragment, baseUrl, hasPushState);\r\n}\r\nfunction _ensureArrayWithSingleRoutePerConfig(config) {\r\n    var routeConfigs = [];\r\n    if (Array.isArray(config.route)) {\r\n        for (var i = 0, ii = config.route.length; i < ii; ++i) {\r\n            var current = Object.assign({}, config);\r\n            current.route = config.route[i];\r\n            routeConfigs.push(current);\r\n        }\r\n    }\r\n    else {\r\n        routeConfigs.push(Object.assign({}, config));\r\n    }\r\n    return routeConfigs;\r\n}\r\nvar isRootedPath = /^#?\\//;\r\nvar isAbsoluteUrl = /^([a-z][a-z0-9+\\-.]*:)?\\/\\//i;\n\n/**\r\n * Class used to configure a [[Router]] instance.\r\n *\r\n * @constructor\r\n */\r\nvar RouterConfiguration = /** @class */ (function () {\r\n    function RouterConfiguration() {\r\n        this.instructions = [];\r\n        this.options = {};\r\n        this.pipelineSteps = [];\r\n    }\r\n    /**\r\n     * Adds a step to be run during the [[Router]]'s navigation pipeline.\r\n     *\r\n     * @param name The name of the pipeline slot to insert the step into.\r\n     * @param step The pipeline step.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.addPipelineStep = function (name, step) {\r\n        if (step === null || step === undefined) {\r\n            throw new Error('Pipeline step cannot be null or undefined.');\r\n        }\r\n        this.pipelineSteps.push({ name: name, step: step });\r\n        return this;\r\n    };\r\n    /**\r\n     * Adds a step to be run during the [[Router]]'s authorize pipeline slot.\r\n     *\r\n     * @param step The pipeline step.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.addAuthorizeStep = function (step) {\r\n        return this.addPipelineStep(\"authorize\" /* Authorize */, step);\r\n    };\r\n    /**\r\n     * Adds a step to be run during the [[Router]]'s preActivate pipeline slot.\r\n     *\r\n     * @param step The pipeline step.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.addPreActivateStep = function (step) {\r\n        return this.addPipelineStep(\"preActivate\" /* PreActivate */, step);\r\n    };\r\n    /**\r\n     * Adds a step to be run during the [[Router]]'s preRender pipeline slot.\r\n     *\r\n     * @param step The pipeline step.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.addPreRenderStep = function (step) {\r\n        return this.addPipelineStep(\"preRender\" /* PreRender */, step);\r\n    };\r\n    /**\r\n     * Adds a step to be run during the [[Router]]'s postRender pipeline slot.\r\n     *\r\n     * @param step The pipeline step.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.addPostRenderStep = function (step) {\r\n        return this.addPipelineStep(\"postRender\" /* PostRender */, step);\r\n    };\r\n    /**\r\n     * Configures a route that will be used if there is no previous location available on navigation cancellation.\r\n     *\r\n     * @param fragment The URL fragment to use as the navigation destination.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.fallbackRoute = function (fragment) {\r\n        this._fallbackRoute = fragment;\r\n        return this;\r\n    };\r\n    /**\r\n     * Maps one or more routes to be registered with the router.\r\n     *\r\n     * @param route The [[RouteConfig]] to map, or an array of [[RouteConfig]] to map.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.map = function (route) {\r\n        var _this = this;\r\n        if (Array.isArray(route)) {\r\n            route.forEach(function (r) { return _this.map(r); });\r\n            return this;\r\n        }\r\n        return this.mapRoute(route);\r\n    };\r\n    /**\r\n     * Configures defaults to use for any view ports.\r\n     *\r\n     * @param viewPortConfig a view port configuration object to use as a\r\n     *  default, of the form { viewPortName: { moduleId } }.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.useViewPortDefaults = function (viewPortConfig) {\r\n        this.viewPortDefaults = viewPortConfig;\r\n        return this;\r\n    };\r\n    /**\r\n     * Maps a single route to be registered with the router.\r\n     *\r\n     * @param route The [[RouteConfig]] to map.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.mapRoute = function (config) {\r\n        this.instructions.push(function (router) {\r\n            var routeConfigs = _ensureArrayWithSingleRoutePerConfig(config);\r\n            var navModel;\r\n            for (var i = 0, ii = routeConfigs.length; i < ii; ++i) {\r\n                var routeConfig = routeConfigs[i];\r\n                routeConfig.settings = routeConfig.settings || {};\r\n                if (!navModel) {\r\n                    navModel = router.createNavModel(routeConfig);\r\n                }\r\n                router.addRoute(routeConfig, navModel);\r\n            }\r\n        });\r\n        return this;\r\n    };\r\n    /**\r\n     * Registers an unknown route handler to be run when the URL fragment doesn't match any registered routes.\r\n     *\r\n     * @param config A string containing a moduleId to load, or a [[RouteConfig]], or a function that takes the\r\n     *  [[NavigationInstruction]] and selects a moduleId to load.\r\n     * @chainable\r\n     */\r\n    RouterConfiguration.prototype.mapUnknownRoutes = function (config) {\r\n        this.unknownRouteConfig = config;\r\n        return this;\r\n    };\r\n    /**\r\n     * Applies the current configuration to the specified [[Router]].\r\n     *\r\n     * @param router The [[Router]] to apply the configuration to.\r\n     */\r\n    RouterConfiguration.prototype.exportToRouter = function (router) {\r\n        var instructions = this.instructions;\r\n        for (var i = 0, ii = instructions.length; i < ii; ++i) {\r\n            instructions[i](router);\r\n        }\r\n        var _a = this, title = _a.title, titleSeparator = _a.titleSeparator, unknownRouteConfig = _a.unknownRouteConfig, _fallbackRoute = _a._fallbackRoute, viewPortDefaults = _a.viewPortDefaults;\r\n        if (title) {\r\n            router.title = title;\r\n        }\r\n        if (titleSeparator) {\r\n            router.titleSeparator = titleSeparator;\r\n        }\r\n        if (unknownRouteConfig) {\r\n            router.handleUnknownRoutes(unknownRouteConfig);\r\n        }\r\n        if (_fallbackRoute) {\r\n            router.fallbackRoute = _fallbackRoute;\r\n        }\r\n        if (viewPortDefaults) {\r\n            router.useViewPortDefaults(viewPortDefaults);\r\n        }\r\n        Object.assign(router.options, this.options);\r\n        var pipelineSteps = this.pipelineSteps;\r\n        var pipelineStepCount = pipelineSteps.length;\r\n        if (pipelineStepCount) {\r\n            if (!router.isRoot) {\r\n                throw new Error('Pipeline steps can only be added to the root router');\r\n            }\r\n            var pipelineProvider = router.pipelineProvider;\r\n            for (var i = 0, ii = pipelineStepCount; i < ii; ++i) {\r\n                var _b = pipelineSteps[i], name_1 = _b.name, step = _b.step;\r\n                pipelineProvider.addStep(name_1, step);\r\n            }\r\n        }\r\n    };\r\n    return RouterConfiguration;\r\n}());\n\n/**\r\n * The primary class responsible for handling routing and navigation.\r\n */\r\nvar Router = /** @class */ (function () {\r\n    /**\r\n     * @param container The [[Container]] to use when child routers.\r\n     * @param history The [[History]] implementation to delegate navigation requests to.\r\n     */\r\n    function Router(container, history) {\r\n        var _this = this;\r\n        /**\r\n         * The parent router, or null if this instance is not a child router.\r\n         */\r\n        this.parent = null;\r\n        this.options = {};\r\n        /**\r\n         * The defaults used when a viewport lacks specified content\r\n         */\r\n        this.viewPortDefaults = {};\r\n        /**\r\n         * Extension point to transform the document title before it is built and displayed.\r\n         * By default, child routers delegate to the parent router, and the app router\r\n         * returns the title unchanged.\r\n         */\r\n        this.transformTitle = function (title) {\r\n            if (_this.parent) {\r\n                return _this.parent.transformTitle(title);\r\n            }\r\n            return title;\r\n        };\r\n        this.container = container;\r\n        this.history = history;\r\n        this.reset();\r\n    }\r\n    /**\r\n     * Fully resets the router's internal state. Primarily used internally by the framework when multiple calls to setRoot are made.\r\n     * Use with caution (actually, avoid using this). Do not use this to simply change your navigation model.\r\n     */\r\n    Router.prototype.reset = function () {\r\n        var _this = this;\r\n        this.viewPorts = {};\r\n        this.routes = [];\r\n        this.baseUrl = '';\r\n        this.isConfigured = false;\r\n        this.isNavigating = false;\r\n        this.isExplicitNavigation = false;\r\n        this.isExplicitNavigationBack = false;\r\n        this.isNavigatingFirst = false;\r\n        this.isNavigatingNew = false;\r\n        this.isNavigatingRefresh = false;\r\n        this.isNavigatingForward = false;\r\n        this.isNavigatingBack = false;\r\n        this.couldDeactivate = false;\r\n        this.navigation = [];\r\n        this.currentInstruction = null;\r\n        this.viewPortDefaults = {};\r\n        this._fallbackOrder = 100;\r\n        this._recognizer = new RouteRecognizer();\r\n        this._childRecognizer = new RouteRecognizer();\r\n        this._configuredPromise = new Promise(function (resolve) {\r\n            _this._resolveConfiguredPromise = resolve;\r\n        });\r\n    };\r\n    Object.defineProperty(Router.prototype, \"isRoot\", {\r\n        /**\r\n         * Gets a value indicating whether or not this [[Router]] is the root in the router tree. I.e., it has no parent.\r\n         */\r\n        get: function () {\r\n            return !this.parent;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    /**\r\n     * Registers a viewPort to be used as a rendering target for activated routes.\r\n     *\r\n     * @param viewPort The viewPort.\r\n     * @param name The name of the viewPort. 'default' if unspecified.\r\n     */\r\n    Router.prototype.registerViewPort = function (viewPort, name) {\r\n        name = name || 'default';\r\n        this.viewPorts[name] = viewPort;\r\n    };\r\n    /**\r\n     * Returns a Promise that resolves when the router is configured.\r\n     */\r\n    Router.prototype.ensureConfigured = function () {\r\n        return this._configuredPromise;\r\n    };\r\n    /**\r\n     * Configures the router.\r\n     *\r\n     * @param callbackOrConfig The [[RouterConfiguration]] or a callback that takes a [[RouterConfiguration]].\r\n     */\r\n    Router.prototype.configure = function (callbackOrConfig) {\r\n        var _this = this;\r\n        this.isConfigured = true;\r\n        var result = callbackOrConfig;\r\n        var config;\r\n        if (typeof callbackOrConfig === 'function') {\r\n            config = new RouterConfiguration();\r\n            result = callbackOrConfig(config);\r\n        }\r\n        return Promise\r\n            .resolve(result)\r\n            .then(function (c) {\r\n            if (c && c.exportToRouter) {\r\n                config = c;\r\n            }\r\n            config.exportToRouter(_this);\r\n            _this.isConfigured = true;\r\n            _this._resolveConfiguredPromise();\r\n        });\r\n    };\r\n    /**\r\n     * Navigates to a new location.\r\n     *\r\n     * @param fragment The URL fragment to use as the navigation destination.\r\n     * @param options The navigation options.\r\n     */\r\n    Router.prototype.navigate = function (fragment, options) {\r\n        if (!this.isConfigured && this.parent) {\r\n            return this.parent.navigate(fragment, options);\r\n        }\r\n        this.isExplicitNavigation = true;\r\n        return this.history.navigate(_resolveUrl(fragment, this.baseUrl, this.history._hasPushState), options);\r\n    };\r\n    /**\r\n     * Navigates to a new location corresponding to the route and params specified. Equivallent to [[Router.generate]] followed\r\n     * by [[Router.navigate]].\r\n     *\r\n     * @param route The name of the route to use when generating the navigation location.\r\n     * @param params The route parameters to be used when populating the route pattern.\r\n     * @param options The navigation options.\r\n     */\r\n    Router.prototype.navigateToRoute = function (route, params, options) {\r\n        var path = this.generate(route, params);\r\n        return this.navigate(path, options);\r\n    };\r\n    /**\r\n     * Navigates back to the most recent location in history.\r\n     */\r\n    Router.prototype.navigateBack = function () {\r\n        this.isExplicitNavigationBack = true;\r\n        this.history.navigateBack();\r\n    };\r\n    /**\r\n     * Creates a child router of the current router.\r\n     *\r\n     * @param container The [[Container]] to provide to the child router. Uses the current [[Router]]'s [[Container]] if unspecified.\r\n     * @returns {Router} The new child Router.\r\n     */\r\n    Router.prototype.createChild = function (container) {\r\n        var childRouter = new Router(container || this.container.createChild(), this.history);\r\n        childRouter.parent = this;\r\n        return childRouter;\r\n    };\r\n    /**\r\n     * Generates a URL fragment matching the specified route pattern.\r\n     *\r\n     * @param name The name of the route whose pattern should be used to generate the fragment.\r\n     * @param params The route params to be used to populate the route pattern.\r\n     * @param options If options.absolute = true, then absolute url will be generated; otherwise, it will be relative url.\r\n     * @returns {string} A string containing the generated URL fragment.\r\n     */\r\n    Router.prototype.generate = function (nameOrRoute, params, options) {\r\n        if (params === void 0) { params = {}; }\r\n        if (options === void 0) { options = {}; }\r\n        // A child recognizer generates routes for potential child routes. Any potential child route is added\r\n        // to the childRoute property of params for the childRouter to recognize. When generating routes, we\r\n        // use the childRecognizer when childRoute params are available to generate a child router enabled route.\r\n        var recognizer = 'childRoute' in params ? this._childRecognizer : this._recognizer;\r\n        var hasRoute = recognizer.hasRoute(nameOrRoute);\r\n        if (!hasRoute) {\r\n            if (this.parent) {\r\n                return this.parent.generate(nameOrRoute, params, options);\r\n            }\r\n            throw new Error(\"A route with name '\" + nameOrRoute + \"' could not be found. Check that `name: '\" + nameOrRoute + \"'` was specified in the route's config.\");\r\n        }\r\n        var path = recognizer.generate(nameOrRoute, params);\r\n        var rootedPath = _createRootedPath(path, this.baseUrl, this.history._hasPushState, options.absolute);\r\n        return options.absolute ? \"\" + this.history.getAbsoluteRoot() + rootedPath : rootedPath;\r\n    };\r\n    /**\r\n     * Creates a [[NavModel]] for the specified route config.\r\n     *\r\n     * @param config The route config.\r\n     */\r\n    Router.prototype.createNavModel = function (config) {\r\n        var navModel = new NavModel(this, 'href' in config\r\n            ? config.href\r\n            // potential error when config.route is a string[] ?\r\n            : config.route);\r\n        navModel.title = config.title;\r\n        navModel.order = config.nav;\r\n        navModel.href = config.href;\r\n        navModel.settings = config.settings;\r\n        navModel.config = config;\r\n        return navModel;\r\n    };\r\n    /**\r\n     * Registers a new route with the router.\r\n     *\r\n     * @param config The [[RouteConfig]].\r\n     * @param navModel The [[NavModel]] to use for the route. May be omitted for single-pattern routes.\r\n     */\r\n    Router.prototype.addRoute = function (config, navModel) {\r\n        if (Array.isArray(config.route)) {\r\n            var routeConfigs = _ensureArrayWithSingleRoutePerConfig(config);\r\n            // the following is wrong. todo: fix this after TS refactoring release\r\n            routeConfigs.forEach(this.addRoute.bind(this));\r\n            return;\r\n        }\r\n        validateRouteConfig(config);\r\n        if (!('viewPorts' in config) && !config.navigationStrategy) {\r\n            config.viewPorts = {\r\n                'default': {\r\n                    moduleId: config.moduleId,\r\n                    view: config.view\r\n                }\r\n            };\r\n        }\r\n        if (!navModel) {\r\n            navModel = this.createNavModel(config);\r\n        }\r\n        this.routes.push(config);\r\n        var path = config.route;\r\n        if (path.charAt(0) === '/') {\r\n            path = path.substr(1);\r\n        }\r\n        var caseSensitive = config.caseSensitive === true;\r\n        var state = this._recognizer.add({\r\n            path: path,\r\n            handler: config,\r\n            caseSensitive: caseSensitive\r\n        });\r\n        if (path) {\r\n            var settings = config.settings;\r\n            delete config.settings;\r\n            var withChild = JSON.parse(JSON.stringify(config));\r\n            config.settings = settings;\r\n            withChild.route = path + \"/*childRoute\";\r\n            withChild.hasChildRouter = true;\r\n            this._childRecognizer.add({\r\n                path: withChild.route,\r\n                handler: withChild,\r\n                caseSensitive: caseSensitive\r\n            });\r\n            withChild.navModel = navModel;\r\n            withChild.settings = config.settings;\r\n            withChild.navigationStrategy = config.navigationStrategy;\r\n        }\r\n        config.navModel = navModel;\r\n        var navigation = this.navigation;\r\n        if ((navModel.order || navModel.order === 0) && navigation.indexOf(navModel) === -1) {\r\n            if ((!navModel.href && navModel.href !== '') && (state.types.dynamics || state.types.stars)) {\r\n                throw new Error('Invalid route config for \"' + config.route + '\" : dynamic routes must specify an \"href:\" to be included in the navigation model.');\r\n            }\r\n            if (typeof navModel.order !== 'number') {\r\n                navModel.order = ++this._fallbackOrder;\r\n            }\r\n            navigation.push(navModel);\r\n            // this is a potential error / inconsistency between browsers\r\n            //\r\n            // MDN: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\r\n            // If compareFunction(a, b) returns 0, leave a and b unchanged with respect to each other,\r\n            // but sorted with respect to all different elements.\r\n            // Note: the ECMAscript standard does not guarantee this behaviour,\r\n            // and thus not all browsers (e.g. Mozilla versions dating back to at least 2003) respect this.\r\n            navigation.sort(function (a, b) { return a.order - b.order; });\r\n        }\r\n    };\r\n    /**\r\n     * Gets a value indicating whether or not this [[Router]] or one of its ancestors has a route registered with the specified name.\r\n     *\r\n     * @param name The name of the route to check.\r\n     */\r\n    Router.prototype.hasRoute = function (name) {\r\n        return !!(this._recognizer.hasRoute(name) || this.parent && this.parent.hasRoute(name));\r\n    };\r\n    /**\r\n     * Gets a value indicating whether or not this [[Router]] has a route registered with the specified name.\r\n     *\r\n     * @param name The name of the route to check.\r\n     */\r\n    Router.prototype.hasOwnRoute = function (name) {\r\n        return this._recognizer.hasRoute(name);\r\n    };\r\n    /**\r\n     * Register a handler to use when the incoming URL fragment doesn't match any registered routes.\r\n     *\r\n     * @param config The moduleId, or a function that selects the moduleId, or a [[RouteConfig]].\r\n     */\r\n    Router.prototype.handleUnknownRoutes = function (config) {\r\n        var _this = this;\r\n        if (!config) {\r\n            throw new Error('Invalid unknown route handler');\r\n        }\r\n        this.catchAllHandler = function (instruction) {\r\n            return _this\r\n                ._createRouteConfig(config, instruction)\r\n                .then(function (c) {\r\n                instruction.config = c;\r\n                return instruction;\r\n            });\r\n        };\r\n    };\r\n    /**\r\n     * Updates the document title using the current navigation instruction.\r\n     */\r\n    Router.prototype.updateTitle = function () {\r\n        var parentRouter = this.parent;\r\n        if (parentRouter) {\r\n            return parentRouter.updateTitle();\r\n        }\r\n        var currentInstruction = this.currentInstruction;\r\n        if (currentInstruction) {\r\n            currentInstruction._updateTitle();\r\n        }\r\n        return undefined;\r\n    };\r\n    /**\r\n     * Updates the navigation routes with hrefs relative to the current location.\r\n     * Note: This method will likely move to a plugin in a future release.\r\n     */\r\n    Router.prototype.refreshNavigation = function () {\r\n        var nav = this.navigation;\r\n        for (var i = 0, length_1 = nav.length; i < length_1; i++) {\r\n            var current = nav[i];\r\n            if (!current.config.href) {\r\n                current.href = _createRootedPath(current.relativeHref, this.baseUrl, this.history._hasPushState);\r\n            }\r\n            else {\r\n                current.href = _normalizeAbsolutePath(current.config.href, this.history._hasPushState);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n     * Sets the default configuration for the view ports. This specifies how to\r\n     *  populate a view port for which no module is specified. The default is\r\n     *  an empty view/view-model pair.\r\n     */\r\n    Router.prototype.useViewPortDefaults = function ($viewPortDefaults) {\r\n        // a workaround to have strong typings while not requiring to expose interface ViewPortInstruction\r\n        var viewPortDefaults = $viewPortDefaults;\r\n        for (var viewPortName in viewPortDefaults) {\r\n            var viewPortConfig = viewPortDefaults[viewPortName];\r\n            this.viewPortDefaults[viewPortName] = {\r\n                moduleId: viewPortConfig.moduleId\r\n            };\r\n        }\r\n    };\r\n    /**@internal */\r\n    Router.prototype._refreshBaseUrl = function () {\r\n        var parentRouter = this.parent;\r\n        if (parentRouter) {\r\n            this.baseUrl = generateBaseUrl(parentRouter, parentRouter.currentInstruction);\r\n        }\r\n    };\r\n    /**@internal */\r\n    Router.prototype._createNavigationInstruction = function (url, parentInstruction) {\r\n        if (url === void 0) { url = ''; }\r\n        if (parentInstruction === void 0) { parentInstruction = null; }\r\n        var fragment = url;\r\n        var queryString = '';\r\n        var queryIndex = url.indexOf('?');\r\n        if (queryIndex !== -1) {\r\n            fragment = url.substr(0, queryIndex);\r\n            queryString = url.substr(queryIndex + 1);\r\n        }\r\n        var urlRecognizationResults = this._recognizer.recognize(url);\r\n        if (!urlRecognizationResults || !urlRecognizationResults.length) {\r\n            urlRecognizationResults = this._childRecognizer.recognize(url);\r\n        }\r\n        var instructionInit = {\r\n            fragment: fragment,\r\n            queryString: queryString,\r\n            config: null,\r\n            parentInstruction: parentInstruction,\r\n            previousInstruction: this.currentInstruction,\r\n            router: this,\r\n            options: {\r\n                compareQueryParams: this.options.compareQueryParams\r\n            }\r\n        };\r\n        var result;\r\n        if (urlRecognizationResults && urlRecognizationResults.length) {\r\n            var first = urlRecognizationResults[0];\r\n            var instruction = new NavigationInstruction(Object.assign({}, instructionInit, {\r\n                params: first.params,\r\n                queryParams: first.queryParams || urlRecognizationResults.queryParams,\r\n                config: first.config || first.handler\r\n            }));\r\n            if (typeof first.handler === 'function') {\r\n                result = evaluateNavigationStrategy(instruction, first.handler, first);\r\n            }\r\n            else if (first.handler && typeof first.handler.navigationStrategy === 'function') {\r\n                result = evaluateNavigationStrategy(instruction, first.handler.navigationStrategy, first.handler);\r\n            }\r\n            else {\r\n                result = Promise.resolve(instruction);\r\n            }\r\n        }\r\n        else if (this.catchAllHandler) {\r\n            var instruction = new NavigationInstruction(Object.assign({}, instructionInit, {\r\n                params: { path: fragment },\r\n                queryParams: urlRecognizationResults ? urlRecognizationResults.queryParams : {},\r\n                config: null // config will be created by the catchAllHandler\r\n            }));\r\n            result = evaluateNavigationStrategy(instruction, this.catchAllHandler);\r\n        }\r\n        else if (this.parent) {\r\n            var router = this._parentCatchAllHandler(this.parent);\r\n            if (router) {\r\n                var newParentInstruction = this._findParentInstructionFromRouter(router, parentInstruction);\r\n                var instruction = new NavigationInstruction(Object.assign({}, instructionInit, {\r\n                    params: { path: fragment },\r\n                    queryParams: urlRecognizationResults ? urlRecognizationResults.queryParams : {},\r\n                    router: router,\r\n                    parentInstruction: newParentInstruction,\r\n                    parentCatchHandler: true,\r\n                    config: null // config will be created by the chained parent catchAllHandler\r\n                }));\r\n                result = evaluateNavigationStrategy(instruction, router.catchAllHandler);\r\n            }\r\n        }\r\n        if (result && parentInstruction) {\r\n            this.baseUrl = generateBaseUrl(this.parent, parentInstruction);\r\n        }\r\n        return result || Promise.reject(new Error(\"Route not found: \" + url));\r\n    };\r\n    /**@internal */\r\n    Router.prototype._findParentInstructionFromRouter = function (router, instruction) {\r\n        if (instruction.router === router) {\r\n            instruction.fragment = router.baseUrl; // need to change the fragment in case of a redirect instead of moduleId\r\n            return instruction;\r\n        }\r\n        else if (instruction.parentInstruction) {\r\n            return this._findParentInstructionFromRouter(router, instruction.parentInstruction);\r\n        }\r\n        return undefined;\r\n    };\r\n    /**@internal */\r\n    Router.prototype._parentCatchAllHandler = function (router) {\r\n        if (router.catchAllHandler) {\r\n            return router;\r\n        }\r\n        else if (router.parent) {\r\n            return this._parentCatchAllHandler(router.parent);\r\n        }\r\n        return false;\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    Router.prototype._createRouteConfig = function (config, instruction) {\r\n        var _this = this;\r\n        return Promise\r\n            .resolve(config)\r\n            .then(function (c) {\r\n            if (typeof c === 'string') {\r\n                return { moduleId: c };\r\n            }\r\n            else if (typeof c === 'function') {\r\n                return c(instruction);\r\n            }\r\n            return c;\r\n        })\r\n            // typing here could be either RouteConfig or RedirectConfig\r\n            // but temporarily treat both as RouteConfig\r\n            // todo: improve typings precision\r\n            .then(function (c) { return typeof c === 'string' ? { moduleId: c } : c; })\r\n            .then(function (c) {\r\n            c.route = instruction.params.path;\r\n            validateRouteConfig(c);\r\n            if (!c.navModel) {\r\n                c.navModel = _this.createNavModel(c);\r\n            }\r\n            return c;\r\n        });\r\n    };\r\n    return Router;\r\n}());\r\n/* @internal exported for unit testing */\r\nvar generateBaseUrl = function (router, instruction) {\r\n    return \"\" + (router.baseUrl || '') + (instruction.getBaseUrl() || '');\r\n};\r\n/* @internal exported for unit testing */\r\nvar validateRouteConfig = function (config) {\r\n    if (typeof config !== 'object') {\r\n        throw new Error('Invalid Route Config');\r\n    }\r\n    if (typeof config.route !== 'string') {\r\n        var name_1 = config.name || '(no name)';\r\n        throw new Error('Invalid Route Config for \"' + name_1 + '\": You must specify a \"route:\" pattern.');\r\n    }\r\n    if (!('redirect' in config || config.moduleId || config.navigationStrategy || config.viewPorts)) {\r\n        throw new Error('Invalid Route Config for \"' + config.route + '\": You must specify a \"moduleId:\", \"redirect:\", \"navigationStrategy:\", or \"viewPorts:\".');\r\n    }\r\n};\r\n/* @internal exported for unit testing */\r\nvar evaluateNavigationStrategy = function (instruction, evaluator, context) {\r\n    return Promise\r\n        .resolve(evaluator.call(context, instruction))\r\n        .then(function () {\r\n        if (!('viewPorts' in instruction.config)) {\r\n            instruction.config.viewPorts = {\r\n                'default': {\r\n                    moduleId: instruction.config.moduleId\r\n                }\r\n            };\r\n        }\r\n        return instruction;\r\n    });\r\n};\n\n/**@internal exported for unit testing */\r\nvar createNextFn = function (instruction, steps) {\r\n    var index = -1;\r\n    var next = function () {\r\n        index++;\r\n        if (index < steps.length) {\r\n            var currentStep = steps[index];\r\n            try {\r\n                return currentStep(instruction, next);\r\n            }\r\n            catch (e) {\r\n                return next.reject(e);\r\n            }\r\n        }\r\n        else {\r\n            return next.complete();\r\n        }\r\n    };\r\n    next.complete = createCompletionHandler(next, \"completed\" /* Completed */);\r\n    next.cancel = createCompletionHandler(next, \"canceled\" /* Canceled */);\r\n    next.reject = createCompletionHandler(next, \"rejected\" /* Rejected */);\r\n    return next;\r\n};\r\n/**@internal exported for unit testing */\r\nvar createCompletionHandler = function (next, status) {\r\n    return function (output) { return Promise\r\n        .resolve({\r\n        status: status,\r\n        output: output,\r\n        completed: status === \"completed\" /* Completed */\r\n    }); };\r\n};\n\n/**\r\n * The class responsible for managing and processing the navigation pipeline.\r\n */\r\nvar Pipeline = /** @class */ (function () {\r\n    function Pipeline() {\r\n        /**\r\n         * The pipeline steps. And steps added via addStep will be converted to a function\r\n         * The actualy running functions with correct step contexts of this pipeline\r\n         */\r\n        this.steps = [];\r\n    }\r\n    /**\r\n     * Adds a step to the pipeline.\r\n     *\r\n     * @param step The pipeline step.\r\n     */\r\n    Pipeline.prototype.addStep = function (step) {\r\n        var run;\r\n        if (typeof step === 'function') {\r\n            run = step;\r\n        }\r\n        else if (typeof step.getSteps === 'function') {\r\n            // getSteps is to enable support open slots\r\n            // where devs can add multiple steps into the same slot name\r\n            var steps = step.getSteps();\r\n            for (var i = 0, l = steps.length; i < l; i++) {\r\n                this.addStep(steps[i]);\r\n            }\r\n            return this;\r\n        }\r\n        else {\r\n            run = step.run.bind(step);\r\n        }\r\n        this.steps.push(run);\r\n        return this;\r\n    };\r\n    /**\r\n     * Runs the pipeline.\r\n     *\r\n     * @param instruction The navigation instruction to process.\r\n     */\r\n    Pipeline.prototype.run = function (instruction) {\r\n        var nextFn = createNextFn(instruction, this.steps);\r\n        return nextFn();\r\n    };\r\n    return Pipeline;\r\n}());\n\n/**\r\n* Determines if the provided object is a navigation command.\r\n* A navigation command is anything with a navigate method.\r\n*\r\n* @param obj The object to check.\r\n*/\r\nfunction isNavigationCommand(obj) {\r\n    return obj && typeof obj.navigate === 'function';\r\n}\r\n/**\r\n* Used during the activation lifecycle to cause a redirect.\r\n*/\r\nvar Redirect = /** @class */ (function () {\r\n    /**\r\n     * @param url The URL fragment to use as the navigation destination.\r\n     * @param options The navigation options.\r\n     */\r\n    function Redirect(url, options) {\r\n        if (options === void 0) { options = {}; }\r\n        this.url = url;\r\n        this.options = Object.assign({ trigger: true, replace: true }, options);\r\n        this.shouldContinueProcessing = false;\r\n    }\r\n    /**\r\n     * Called by the activation system to set the child router.\r\n     *\r\n     * @param router The router.\r\n     */\r\n    Redirect.prototype.setRouter = function (router) {\r\n        this.router = router;\r\n    };\r\n    /**\r\n     * Called by the navigation pipeline to navigate.\r\n     *\r\n     * @param appRouter The router to be redirected.\r\n     */\r\n    Redirect.prototype.navigate = function (appRouter) {\r\n        var navigatingRouter = this.options.useAppRouter ? appRouter : (this.router || appRouter);\r\n        navigatingRouter.navigate(this.url, this.options);\r\n    };\r\n    return Redirect;\r\n}());\r\n/**\r\n * Used during the activation lifecycle to cause a redirect to a named route.\r\n */\r\nvar RedirectToRoute = /** @class */ (function () {\r\n    /**\r\n     * @param route The name of the route.\r\n     * @param params The parameters to be sent to the activation method.\r\n     * @param options The options to use for navigation.\r\n     */\r\n    function RedirectToRoute(route, params, options) {\r\n        if (params === void 0) { params = {}; }\r\n        if (options === void 0) { options = {}; }\r\n        this.route = route;\r\n        this.params = params;\r\n        this.options = Object.assign({ trigger: true, replace: true }, options);\r\n        this.shouldContinueProcessing = false;\r\n    }\r\n    /**\r\n     * Called by the activation system to set the child router.\r\n     *\r\n     * @param router The router.\r\n     */\r\n    RedirectToRoute.prototype.setRouter = function (router) {\r\n        this.router = router;\r\n    };\r\n    /**\r\n     * Called by the navigation pipeline to navigate.\r\n     *\r\n     * @param appRouter The router to be redirected.\r\n     */\r\n    RedirectToRoute.prototype.navigate = function (appRouter) {\r\n        var navigatingRouter = this.options.useAppRouter ? appRouter : (this.router || appRouter);\r\n        navigatingRouter.navigateToRoute(this.route, this.params, this.options);\r\n    };\r\n    return RedirectToRoute;\r\n}());\n\n/**\r\n * @internal exported for unit testing\r\n */\r\nfunction _buildNavigationPlan(instruction, forceLifecycleMinimum) {\r\n    var config = instruction.config;\r\n    if ('redirect' in config) {\r\n        return buildRedirectPlan(instruction);\r\n    }\r\n    var prevInstruction = instruction.previousInstruction;\r\n    var defaultViewPortConfigs = instruction.router.viewPortDefaults;\r\n    if (prevInstruction) {\r\n        return buildTransitionPlans(instruction, prevInstruction, defaultViewPortConfigs, forceLifecycleMinimum);\r\n    }\r\n    // first navigation, only need to prepare a few information for each viewport plan\r\n    var viewPortPlans = {};\r\n    var viewPortConfigs = config.viewPorts;\r\n    for (var viewPortName in viewPortConfigs) {\r\n        var viewPortConfig = viewPortConfigs[viewPortName];\r\n        if (viewPortConfig.moduleId === null && viewPortName in defaultViewPortConfigs) {\r\n            viewPortConfig = defaultViewPortConfigs[viewPortName];\r\n        }\r\n        viewPortPlans[viewPortName] = {\r\n            name: viewPortName,\r\n            strategy: \"replace\" /* Replace */,\r\n            config: viewPortConfig\r\n        };\r\n    }\r\n    return Promise.resolve(viewPortPlans);\r\n}\r\n/**\r\n * Build redirect plan based on config of a navigation instruction\r\n * @internal exported for unit testing\r\n */\r\nvar buildRedirectPlan = function (instruction) {\r\n    var config = instruction.config;\r\n    var router = instruction.router;\r\n    return router\r\n        ._createNavigationInstruction(config.redirect)\r\n        .then(function (redirectInstruction) {\r\n        var params = {};\r\n        var originalInstructionParams = instruction.params;\r\n        var redirectInstructionParams = redirectInstruction.params;\r\n        for (var key in redirectInstructionParams) {\r\n            // If the param on the redirect points to another param, e.g. { route: first/:this, redirect: second/:this }\r\n            var val = redirectInstructionParams[key];\r\n            if (typeof val === 'string' && val[0] === ':') {\r\n                val = val.slice(1);\r\n                // And if that param is found on the original instruction then use it\r\n                if (val in originalInstructionParams) {\r\n                    params[key] = originalInstructionParams[val];\r\n                }\r\n            }\r\n            else {\r\n                params[key] = redirectInstructionParams[key];\r\n            }\r\n        }\r\n        var redirectLocation = router.generate(redirectInstruction.config, params, instruction.options);\r\n        // Special handling for child routes\r\n        for (var key in originalInstructionParams) {\r\n            redirectLocation = redirectLocation.replace(\":\" + key, originalInstructionParams[key]);\r\n        }\r\n        var queryString = instruction.queryString;\r\n        if (queryString) {\r\n            redirectLocation += '?' + queryString;\r\n        }\r\n        return Promise.resolve(new Redirect(redirectLocation));\r\n    });\r\n};\r\n/**\r\n * @param viewPortPlans the Plan record that holds information about built plans\r\n * @internal exported for unit testing\r\n */\r\nvar buildTransitionPlans = function (currentInstruction, previousInstruction, defaultViewPortConfigs, forceLifecycleMinimum) {\r\n    var viewPortPlans = {};\r\n    var newInstructionConfig = currentInstruction.config;\r\n    var hasNewParams = hasDifferentParameterValues(previousInstruction, currentInstruction);\r\n    var pending = [];\r\n    var previousViewPortInstructions = previousInstruction.viewPortInstructions;\r\n    var _loop_1 = function (viewPortName) {\r\n        var prevViewPortInstruction = previousViewPortInstructions[viewPortName];\r\n        var prevViewPortComponent = prevViewPortInstruction.component;\r\n        var newInstructionViewPortConfigs = newInstructionConfig.viewPorts;\r\n        // if this is invoked on a viewport without any changes, based on new url,\r\n        // newViewPortConfig will be the existing viewport instruction\r\n        var nextViewPortConfig = viewPortName in newInstructionViewPortConfigs\r\n            ? newInstructionViewPortConfigs[viewPortName]\r\n            : prevViewPortInstruction;\r\n        if (nextViewPortConfig.moduleId === null && viewPortName in defaultViewPortConfigs) {\r\n            nextViewPortConfig = defaultViewPortConfigs[viewPortName];\r\n        }\r\n        var viewPortActivationStrategy = determineActivationStrategy(currentInstruction, prevViewPortInstruction, nextViewPortConfig, hasNewParams, forceLifecycleMinimum);\r\n        var viewPortPlan = viewPortPlans[viewPortName] = {\r\n            name: viewPortName,\r\n            // ViewPortInstruction can quack like a RouteConfig\r\n            config: nextViewPortConfig,\r\n            prevComponent: prevViewPortComponent,\r\n            prevModuleId: prevViewPortInstruction.moduleId,\r\n            strategy: viewPortActivationStrategy\r\n        };\r\n        // recursively build nav plans for all existing child routers/viewports of this viewport\r\n        // this is possible because existing child viewports and routers already have necessary information\r\n        // to process the wildcard path from parent instruction\r\n        if (viewPortActivationStrategy !== \"replace\" /* Replace */ && prevViewPortInstruction.childRouter) {\r\n            var path = currentInstruction.getWildcardPath();\r\n            var task = prevViewPortInstruction\r\n                .childRouter\r\n                ._createNavigationInstruction(path, currentInstruction)\r\n                .then(function (childInstruction) {\r\n                viewPortPlan.childNavigationInstruction = childInstruction;\r\n                return _buildNavigationPlan(childInstruction, \r\n                // is it safe to assume viewPortPlan has not been changed from previous assignment?\r\n                // if so, can just use local variable viewPortPlanStrategy\r\n                // there could be user code modifying viewport plan during _createNavigationInstruction?\r\n                viewPortPlan.strategy === \"invoke-lifecycle\" /* InvokeLifecycle */)\r\n                    .then(function (childPlan) {\r\n                    if (childPlan instanceof Redirect) {\r\n                        return Promise.reject(childPlan);\r\n                    }\r\n                    childInstruction.plan = childPlan;\r\n                    // for bluebird ?\r\n                    return null;\r\n                });\r\n            });\r\n            pending.push(task);\r\n        }\r\n    };\r\n    for (var viewPortName in previousViewPortInstructions) {\r\n        _loop_1(viewPortName);\r\n    }\r\n    return Promise.all(pending).then(function () { return viewPortPlans; });\r\n};\r\n/**\r\n * @param newViewPortConfig if this is invoked on a viewport without any changes, based on new url, newViewPortConfig will be the existing viewport instruction\r\n * @internal exported for unit testing\r\n */\r\nvar determineActivationStrategy = function (currentNavInstruction, prevViewPortInstruction, newViewPortConfig, \r\n// indicates whether there is difference between old and new url params\r\nhasNewParams, forceLifecycleMinimum) {\r\n    var newInstructionConfig = currentNavInstruction.config;\r\n    var prevViewPortViewModel = prevViewPortInstruction.component.viewModel;\r\n    var viewPortPlanStrategy;\r\n    if (prevViewPortInstruction.moduleId !== newViewPortConfig.moduleId) {\r\n        viewPortPlanStrategy = \"replace\" /* Replace */;\r\n    }\r\n    else if ('determineActivationStrategy' in prevViewPortViewModel) {\r\n        viewPortPlanStrategy = prevViewPortViewModel.determineActivationStrategy.apply(prevViewPortViewModel, currentNavInstruction.lifecycleArgs);\r\n    }\r\n    else if (newInstructionConfig.activationStrategy) {\r\n        viewPortPlanStrategy = newInstructionConfig.activationStrategy;\r\n    }\r\n    else if (hasNewParams || forceLifecycleMinimum) {\r\n        viewPortPlanStrategy = \"invoke-lifecycle\" /* InvokeLifecycle */;\r\n    }\r\n    else {\r\n        viewPortPlanStrategy = \"no-change\" /* NoChange */;\r\n    }\r\n    return viewPortPlanStrategy;\r\n};\r\n/**@internal exported for unit testing */\r\nvar hasDifferentParameterValues = function (prev, next) {\r\n    var prevParams = prev.params;\r\n    var nextParams = next.params;\r\n    var nextWildCardName = next.config.hasChildRouter ? next.getWildCardName() : null;\r\n    for (var key in nextParams) {\r\n        if (key === nextWildCardName) {\r\n            continue;\r\n        }\r\n        if (prevParams[key] !== nextParams[key]) {\r\n            return true;\r\n        }\r\n    }\r\n    for (var key in prevParams) {\r\n        if (key === nextWildCardName) {\r\n            continue;\r\n        }\r\n        if (prevParams[key] !== nextParams[key]) {\r\n            return true;\r\n        }\r\n    }\r\n    if (!next.options.compareQueryParams) {\r\n        return false;\r\n    }\r\n    var prevQueryParams = prev.queryParams;\r\n    var nextQueryParams = next.queryParams;\r\n    for (var key in nextQueryParams) {\r\n        if (prevQueryParams[key] !== nextQueryParams[key]) {\r\n            return true;\r\n        }\r\n    }\r\n    for (var key in prevQueryParams) {\r\n        if (prevQueryParams[key] !== nextQueryParams[key]) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n};\n\n/**\r\n * Transform a navigation instruction into viewport plan record object,\r\n * or a redirect request if user viewmodel demands\r\n */\r\nvar BuildNavigationPlanStep = /** @class */ (function () {\r\n    function BuildNavigationPlanStep() {\r\n    }\r\n    BuildNavigationPlanStep.prototype.run = function (navigationInstruction, next) {\r\n        return _buildNavigationPlan(navigationInstruction)\r\n            .then(function (plan) {\r\n            if (plan instanceof Redirect) {\r\n                return next.cancel(plan);\r\n            }\r\n            navigationInstruction.plan = plan;\r\n            return next();\r\n        })\r\n            .catch(next.cancel);\r\n    };\r\n    return BuildNavigationPlanStep;\r\n}());\n\n/**\r\n * @internal Exported for unit testing\r\n */\r\nvar loadNewRoute = function (routeLoader, navigationInstruction) {\r\n    var loadingPlans = determineLoadingPlans(navigationInstruction);\r\n    var loadPromises = loadingPlans.map(function (loadingPlan) { return loadRoute(routeLoader, loadingPlan.navigationInstruction, loadingPlan.viewPortPlan); });\r\n    return Promise.all(loadPromises);\r\n};\r\n/**\r\n * @internal Exported for unit testing\r\n */\r\nvar determineLoadingPlans = function (navigationInstruction, loadingPlans) {\r\n    if (loadingPlans === void 0) { loadingPlans = []; }\r\n    var viewPortPlans = navigationInstruction.plan;\r\n    for (var viewPortName in viewPortPlans) {\r\n        var viewPortPlan = viewPortPlans[viewPortName];\r\n        var childNavInstruction = viewPortPlan.childNavigationInstruction;\r\n        if (viewPortPlan.strategy === \"replace\" /* Replace */) {\r\n            loadingPlans.push({ viewPortPlan: viewPortPlan, navigationInstruction: navigationInstruction });\r\n            if (childNavInstruction) {\r\n                determineLoadingPlans(childNavInstruction, loadingPlans);\r\n            }\r\n        }\r\n        else {\r\n            var viewPortInstruction = navigationInstruction.addViewPortInstruction({\r\n                name: viewPortName,\r\n                strategy: viewPortPlan.strategy,\r\n                moduleId: viewPortPlan.prevModuleId,\r\n                component: viewPortPlan.prevComponent\r\n            });\r\n            if (childNavInstruction) {\r\n                viewPortInstruction.childNavigationInstruction = childNavInstruction;\r\n                determineLoadingPlans(childNavInstruction, loadingPlans);\r\n            }\r\n        }\r\n    }\r\n    return loadingPlans;\r\n};\r\n/**\r\n * @internal Exported for unit testing\r\n */\r\nvar loadRoute = function (routeLoader, navigationInstruction, viewPortPlan) {\r\n    var planConfig = viewPortPlan.config;\r\n    var moduleId = planConfig ? planConfig.moduleId : null;\r\n    return loadComponent(routeLoader, navigationInstruction, planConfig)\r\n        .then(function (component) {\r\n        var viewPortInstruction = navigationInstruction.addViewPortInstruction({\r\n            name: viewPortPlan.name,\r\n            strategy: viewPortPlan.strategy,\r\n            moduleId: moduleId,\r\n            component: component\r\n        });\r\n        var childRouter = component.childRouter;\r\n        if (childRouter) {\r\n            var path = navigationInstruction.getWildcardPath();\r\n            return childRouter\r\n                ._createNavigationInstruction(path, navigationInstruction)\r\n                .then(function (childInstruction) {\r\n                viewPortPlan.childNavigationInstruction = childInstruction;\r\n                return _buildNavigationPlan(childInstruction)\r\n                    .then(function (childPlan) {\r\n                    if (childPlan instanceof Redirect) {\r\n                        return Promise.reject(childPlan);\r\n                    }\r\n                    childInstruction.plan = childPlan;\r\n                    viewPortInstruction.childNavigationInstruction = childInstruction;\r\n                    return loadNewRoute(routeLoader, childInstruction);\r\n                });\r\n            });\r\n        }\r\n        // ts complains without this, though they are same\r\n        return void 0;\r\n    });\r\n};\r\n/**\r\n * Load a routed-component based on navigation instruction and route config\r\n * @internal exported for unit testing only\r\n */\r\nvar loadComponent = function (routeLoader, navigationInstruction, config) {\r\n    var router = navigationInstruction.router;\r\n    var lifecycleArgs = navigationInstruction.lifecycleArgs;\r\n    return Promise.resolve()\r\n        .then(function () { return routeLoader.loadRoute(router, config, navigationInstruction); })\r\n        .then(\r\n    /**\r\n     * @param component an object carrying information about loaded route\r\n     * typically contains information about view model, childContainer, view and router\r\n     */\r\n    function (component) {\r\n        var viewModel = component.viewModel, childContainer = component.childContainer;\r\n        component.router = router;\r\n        component.config = config;\r\n        if ('configureRouter' in viewModel) {\r\n            var childRouter_1 = childContainer.getChildRouter();\r\n            component.childRouter = childRouter_1;\r\n            return childRouter_1\r\n                .configure(function (c) { return viewModel.configureRouter(c, childRouter_1, lifecycleArgs[0], lifecycleArgs[1], lifecycleArgs[2]); })\r\n                .then(function () { return component; });\r\n        }\r\n        return component;\r\n    });\r\n};\n\n/**\r\n * Abstract class that is responsible for loading view / view model from a route config\r\n * The default implementation can be found in `aurelia-templating-router`\r\n */\r\nvar RouteLoader = /** @class */ (function () {\r\n    function RouteLoader() {\r\n    }\r\n    /**\r\n     * Load a route config based on its viewmodel / view configuration\r\n     */\r\n    // return typing: return typings used to be never\r\n    // as it was a throw. Changing it to Promise<any> should not cause any issues\r\n    RouteLoader.prototype.loadRoute = function (router, config, navigationInstruction) {\r\n        throw new Error('Route loaders must implement \"loadRoute(router, config, navigationInstruction)\".');\r\n    };\r\n    return RouteLoader;\r\n}());\n\n/**\r\n * A pipeline step responsible for loading a route config of a navigation instruction\r\n */\r\nvar LoadRouteStep = /** @class */ (function () {\r\n    function LoadRouteStep(routeLoader) {\r\n        this.routeLoader = routeLoader;\r\n    }\r\n    /**@internal */\r\n    LoadRouteStep.inject = function () { return [RouteLoader]; };\r\n    /**\r\n     * Run the internal to load route config of a navigation instruction to prepare for next steps in the pipeline\r\n     */\r\n    LoadRouteStep.prototype.run = function (navigationInstruction, next) {\r\n        return loadNewRoute(this.routeLoader, navigationInstruction)\r\n            .then(next, next.cancel);\r\n    };\r\n    return LoadRouteStep;\r\n}());\n\n/**\r\n * A pipeline step for instructing a piepline to commit changes on a navigation instruction\r\n */\r\nvar CommitChangesStep = /** @class */ (function () {\r\n    function CommitChangesStep() {\r\n    }\r\n    CommitChangesStep.prototype.run = function (navigationInstruction, next) {\r\n        return navigationInstruction\r\n            ._commitChanges(/*wait to swap?*/ true)\r\n            .then(function () {\r\n            navigationInstruction._updateTitle();\r\n            return next();\r\n        });\r\n    };\r\n    return CommitChangesStep;\r\n}());\n\n/**\r\n * An optional interface describing the available activation strategies.\r\n * @internal Used internally.\r\n */\r\nvar InternalActivationStrategy;\r\n(function (InternalActivationStrategy) {\r\n    /**\r\n     * Reuse the existing view model, without invoking Router lifecycle hooks.\r\n     */\r\n    InternalActivationStrategy[\"NoChange\"] = \"no-change\";\r\n    /**\r\n     * Reuse the existing view model, invoking Router lifecycle hooks.\r\n     */\r\n    InternalActivationStrategy[\"InvokeLifecycle\"] = \"invoke-lifecycle\";\r\n    /**\r\n     * Replace the existing view model, invoking Router lifecycle hooks.\r\n     */\r\n    InternalActivationStrategy[\"Replace\"] = \"replace\";\r\n})(InternalActivationStrategy || (InternalActivationStrategy = {}));\r\n/**\r\n * The strategy to use when activating modules during navigation.\r\n */\r\n// kept for compat reason\r\nvar activationStrategy = {\r\n    noChange: \"no-change\" /* NoChange */,\r\n    invokeLifecycle: \"invoke-lifecycle\" /* InvokeLifecycle */,\r\n    replace: \"replace\" /* Replace */\r\n};\n\n/**\r\n * Recursively find list of deactivate-able view models\r\n * and invoke the either 'canDeactivate' or 'deactivate' on each\r\n * @internal exported for unit testing\r\n */\r\nvar processDeactivatable = function (navigationInstruction, callbackName, next, ignoreResult) {\r\n    var plan = navigationInstruction.plan;\r\n    var infos = findDeactivatable(plan, callbackName);\r\n    var i = infos.length; // query from inside out\r\n    function inspect(val) {\r\n        if (ignoreResult || shouldContinue(val)) {\r\n            return iterate();\r\n        }\r\n        return next.cancel(val);\r\n    }\r\n    function iterate() {\r\n        if (i--) {\r\n            try {\r\n                var viewModel = infos[i];\r\n                var result = viewModel[callbackName](navigationInstruction);\r\n                return processPotential(result, inspect, next.cancel);\r\n            }\r\n            catch (error) {\r\n                return next.cancel(error);\r\n            }\r\n        }\r\n        navigationInstruction.router.couldDeactivate = true;\r\n        return next();\r\n    }\r\n    return iterate();\r\n};\r\n/**\r\n * Recursively find and returns a list of deactivate-able view models\r\n * @internal exported for unit testing\r\n */\r\nvar findDeactivatable = function (plan, callbackName, list) {\r\n    if (list === void 0) { list = []; }\r\n    for (var viewPortName in plan) {\r\n        var viewPortPlan = plan[viewPortName];\r\n        var prevComponent = viewPortPlan.prevComponent;\r\n        if ((viewPortPlan.strategy === activationStrategy.invokeLifecycle || viewPortPlan.strategy === activationStrategy.replace)\r\n            && prevComponent) {\r\n            var viewModel = prevComponent.viewModel;\r\n            if (callbackName in viewModel) {\r\n                list.push(viewModel);\r\n            }\r\n        }\r\n        if (viewPortPlan.strategy === activationStrategy.replace && prevComponent) {\r\n            addPreviousDeactivatable(prevComponent, callbackName, list);\r\n        }\r\n        else if (viewPortPlan.childNavigationInstruction) {\r\n            findDeactivatable(viewPortPlan.childNavigationInstruction.plan, callbackName, list);\r\n        }\r\n    }\r\n    return list;\r\n};\r\n/**\r\n * @internal exported for unit testing\r\n */\r\nvar addPreviousDeactivatable = function (component, callbackName, list) {\r\n    var childRouter = component.childRouter;\r\n    if (childRouter && childRouter.currentInstruction) {\r\n        var viewPortInstructions = childRouter.currentInstruction.viewPortInstructions;\r\n        for (var viewPortName in viewPortInstructions) {\r\n            var viewPortInstruction = viewPortInstructions[viewPortName];\r\n            var prevComponent = viewPortInstruction.component;\r\n            var prevViewModel = prevComponent.viewModel;\r\n            if (callbackName in prevViewModel) {\r\n                list.push(prevViewModel);\r\n            }\r\n            addPreviousDeactivatable(prevComponent, callbackName, list);\r\n        }\r\n    }\r\n};\r\n/**\r\n * @internal exported for unit testing\r\n */\r\nvar processActivatable = function (navigationInstruction, callbackName, next, ignoreResult) {\r\n    var infos = findActivatable(navigationInstruction, callbackName);\r\n    var length = infos.length;\r\n    var i = -1; // query from top down\r\n    function inspect(val, router) {\r\n        if (ignoreResult || shouldContinue(val, router)) {\r\n            return iterate();\r\n        }\r\n        return next.cancel(val);\r\n    }\r\n    function iterate() {\r\n        var _a;\r\n        i++;\r\n        if (i < length) {\r\n            try {\r\n                var current_1 = infos[i];\r\n                var result = (_a = current_1.viewModel)[callbackName].apply(_a, current_1.lifecycleArgs);\r\n                return processPotential(result, function (val) { return inspect(val, current_1.router); }, next.cancel);\r\n            }\r\n            catch (error) {\r\n                return next.cancel(error);\r\n            }\r\n        }\r\n        return next();\r\n    }\r\n    return iterate();\r\n};\r\n/**\r\n * Find list of activatable view model and add to list (3rd parameter)\r\n * @internal exported for unit testing\r\n */\r\nvar findActivatable = function (navigationInstruction, callbackName, list, router) {\r\n    if (list === void 0) { list = []; }\r\n    var plan = navigationInstruction.plan;\r\n    Object\r\n        .keys(plan)\r\n        .forEach(function (viewPortName) {\r\n        var viewPortPlan = plan[viewPortName];\r\n        var viewPortInstruction = navigationInstruction.viewPortInstructions[viewPortName];\r\n        var viewPortComponent = viewPortInstruction.component;\r\n        var viewModel = viewPortComponent.viewModel;\r\n        if ((viewPortPlan.strategy === activationStrategy.invokeLifecycle\r\n            || viewPortPlan.strategy === activationStrategy.replace)\r\n            && callbackName in viewModel) {\r\n            list.push({\r\n                viewModel: viewModel,\r\n                lifecycleArgs: viewPortInstruction.lifecycleArgs,\r\n                router: router\r\n            });\r\n        }\r\n        var childNavInstruction = viewPortPlan.childNavigationInstruction;\r\n        if (childNavInstruction) {\r\n            findActivatable(childNavInstruction, callbackName, list, viewPortComponent.childRouter || router);\r\n        }\r\n    });\r\n    return list;\r\n};\r\nvar shouldContinue = function (output, router) {\r\n    if (output instanceof Error) {\r\n        return false;\r\n    }\r\n    if (isNavigationCommand(output)) {\r\n        if (typeof output.setRouter === 'function') {\r\n            output.setRouter(router);\r\n        }\r\n        return !!output.shouldContinueProcessing;\r\n    }\r\n    if (output === undefined) {\r\n        return true;\r\n    }\r\n    return output;\r\n};\r\n/**\r\n * wraps a subscription, allowing unsubscribe calls even if\r\n * the first value comes synchronously\r\n */\r\nvar SafeSubscription = /** @class */ (function () {\r\n    function SafeSubscription(subscriptionFunc) {\r\n        this._subscribed = true;\r\n        this._subscription = subscriptionFunc(this);\r\n        if (!this._subscribed) {\r\n            this.unsubscribe();\r\n        }\r\n    }\r\n    Object.defineProperty(SafeSubscription.prototype, \"subscribed\", {\r\n        get: function () {\r\n            return this._subscribed;\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    SafeSubscription.prototype.unsubscribe = function () {\r\n        if (this._subscribed && this._subscription) {\r\n            this._subscription.unsubscribe();\r\n        }\r\n        this._subscribed = false;\r\n    };\r\n    return SafeSubscription;\r\n}());\r\n/**\r\n * A function to process return value from `activate`/`canActivate` steps\r\n * Supports observable/promise\r\n *\r\n * For observable, resolve at first next() or on complete()\r\n */\r\nvar processPotential = function (obj, resolve, reject) {\r\n    // if promise like\r\n    if (obj && typeof obj.then === 'function') {\r\n        return Promise.resolve(obj).then(resolve).catch(reject);\r\n    }\r\n    // if observable\r\n    if (obj && typeof obj.subscribe === 'function') {\r\n        var obs_1 = obj;\r\n        return new SafeSubscription(function (sub) { return obs_1.subscribe({\r\n            next: function () {\r\n                if (sub.subscribed) {\r\n                    sub.unsubscribe();\r\n                    resolve(obj);\r\n                }\r\n            },\r\n            error: function (error) {\r\n                if (sub.subscribed) {\r\n                    sub.unsubscribe();\r\n                    reject(error);\r\n                }\r\n            },\r\n            complete: function () {\r\n                if (sub.subscribed) {\r\n                    sub.unsubscribe();\r\n                    resolve(obj);\r\n                }\r\n            }\r\n        }); });\r\n    }\r\n    // else just resolve\r\n    try {\r\n        return resolve(obj);\r\n    }\r\n    catch (error) {\r\n        return reject(error);\r\n    }\r\n};\n\n/**\r\n * A pipeline step responsible for finding and activating method `canDeactivate` on a view model of a route\r\n */\r\nvar CanDeactivatePreviousStep = /** @class */ (function () {\r\n    function CanDeactivatePreviousStep() {\r\n    }\r\n    CanDeactivatePreviousStep.prototype.run = function (navigationInstruction, next) {\r\n        return processDeactivatable(navigationInstruction, 'canDeactivate', next);\r\n    };\r\n    return CanDeactivatePreviousStep;\r\n}());\r\n/**\r\n * A pipeline step responsible for finding and activating method `canActivate` on a view model of a route\r\n */\r\nvar CanActivateNextStep = /** @class */ (function () {\r\n    function CanActivateNextStep() {\r\n    }\r\n    CanActivateNextStep.prototype.run = function (navigationInstruction, next) {\r\n        return processActivatable(navigationInstruction, 'canActivate', next);\r\n    };\r\n    return CanActivateNextStep;\r\n}());\r\n/**\r\n * A pipeline step responsible for finding and activating method `deactivate` on a view model of a route\r\n */\r\nvar DeactivatePreviousStep = /** @class */ (function () {\r\n    function DeactivatePreviousStep() {\r\n    }\r\n    DeactivatePreviousStep.prototype.run = function (navigationInstruction, next) {\r\n        return processDeactivatable(navigationInstruction, 'deactivate', next, true);\r\n    };\r\n    return DeactivatePreviousStep;\r\n}());\r\n/**\r\n * A pipeline step responsible for finding and activating method `activate` on a view model of a route\r\n */\r\nvar ActivateNextStep = /** @class */ (function () {\r\n    function ActivateNextStep() {\r\n    }\r\n    ActivateNextStep.prototype.run = function (navigationInstruction, next) {\r\n        return processActivatable(navigationInstruction, 'activate', next, true);\r\n    };\r\n    return ActivateNextStep;\r\n}());\n\n/**\r\n * A multi-slots Pipeline Placeholder Step for hooking into a pipeline execution\r\n */\r\nvar PipelineSlot = /** @class */ (function () {\r\n    function PipelineSlot(container, name, alias) {\r\n        this.steps = [];\r\n        this.container = container;\r\n        this.slotName = name;\r\n        this.slotAlias = alias;\r\n    }\r\n    PipelineSlot.prototype.getSteps = function () {\r\n        var _this = this;\r\n        return this.steps.map(function (x) { return _this.container.get(x); });\r\n    };\r\n    return PipelineSlot;\r\n}());\r\n/**\r\n * Class responsible for creating the navigation pipeline.\r\n */\r\nvar PipelineProvider = /** @class */ (function () {\r\n    function PipelineProvider(container) {\r\n        this.container = container;\r\n        this.steps = [\r\n            BuildNavigationPlanStep,\r\n            CanDeactivatePreviousStep,\r\n            LoadRouteStep,\r\n            createPipelineSlot(container, \"authorize\" /* Authorize */),\r\n            CanActivateNextStep,\r\n            createPipelineSlot(container, \"preActivate\" /* PreActivate */, 'modelbind'),\r\n            // NOTE: app state changes start below - point of no return\r\n            DeactivatePreviousStep,\r\n            ActivateNextStep,\r\n            createPipelineSlot(container, \"preRender\" /* PreRender */, 'precommit'),\r\n            CommitChangesStep,\r\n            createPipelineSlot(container, \"postRender\" /* PostRender */, 'postcomplete')\r\n        ];\r\n    }\r\n    /**@internal */\r\n    PipelineProvider.inject = function () { return [Container]; };\r\n    /**\r\n     * Create the navigation pipeline.\r\n     */\r\n    PipelineProvider.prototype.createPipeline = function (useCanDeactivateStep) {\r\n        var _this = this;\r\n        if (useCanDeactivateStep === void 0) { useCanDeactivateStep = true; }\r\n        var pipeline = new Pipeline();\r\n        this.steps.forEach(function (step) {\r\n            if (useCanDeactivateStep || step !== CanDeactivatePreviousStep) {\r\n                pipeline.addStep(_this.container.get(step));\r\n            }\r\n        });\r\n        return pipeline;\r\n    };\r\n    /**@internal */\r\n    PipelineProvider.prototype._findStep = function (name) {\r\n        // Steps that are not PipelineSlots are constructor functions, and they will automatically fail. Probably.\r\n        return this.steps.find(function (x) { return x.slotName === name || x.slotAlias === name; });\r\n    };\r\n    /**\r\n     * Adds a step into the pipeline at a known slot location.\r\n     */\r\n    PipelineProvider.prototype.addStep = function (name, step) {\r\n        var found = this._findStep(name);\r\n        if (found) {\r\n            var slotSteps = found.steps;\r\n            // prevent duplicates\r\n            if (!slotSteps.includes(step)) {\r\n                slotSteps.push(step);\r\n            }\r\n        }\r\n        else {\r\n            throw new Error(\"Invalid pipeline slot name: \" + name + \".\");\r\n        }\r\n    };\r\n    /**\r\n     * Removes a step from a slot in the pipeline\r\n     */\r\n    PipelineProvider.prototype.removeStep = function (name, step) {\r\n        var slot = this._findStep(name);\r\n        if (slot) {\r\n            var slotSteps = slot.steps;\r\n            slotSteps.splice(slotSteps.indexOf(step), 1);\r\n        }\r\n    };\r\n    /**\r\n     * Clears all steps from a slot in the pipeline\r\n     * @internal\r\n     */\r\n    PipelineProvider.prototype._clearSteps = function (name) {\r\n        if (name === void 0) { name = ''; }\r\n        var slot = this._findStep(name);\r\n        if (slot) {\r\n            slot.steps = [];\r\n        }\r\n    };\r\n    /**\r\n     * Resets all pipeline slots\r\n     */\r\n    PipelineProvider.prototype.reset = function () {\r\n        this._clearSteps(\"authorize\" /* Authorize */);\r\n        this._clearSteps(\"preActivate\" /* PreActivate */);\r\n        this._clearSteps(\"preRender\" /* PreRender */);\r\n        this._clearSteps(\"postRender\" /* PostRender */);\r\n    };\r\n    return PipelineProvider;\r\n}());\r\n/**@internal */\r\nvar createPipelineSlot = function (container, name, alias) {\r\n    return new PipelineSlot(container, name, alias);\r\n};\n\nvar logger = getLogger('app-router');\r\n/**\r\n * The main application router.\r\n */\r\nvar AppRouter = /** @class */ (function (_super) {\r\n    __extends(AppRouter, _super);\r\n    function AppRouter(container, history, pipelineProvider, events) {\r\n        var _this = _super.call(this, container, history) || this;\r\n        _this.pipelineProvider = pipelineProvider;\r\n        _this.events = events;\r\n        return _this;\r\n    }\r\n    /**@internal */\r\n    AppRouter.inject = function () { return [Container, History, PipelineProvider, EventAggregator]; };\r\n    /**\r\n     * Fully resets the router's internal state. Primarily used internally by the framework when multiple calls to setRoot are made.\r\n     * Use with caution (actually, avoid using this). Do not use this to simply change your navigation model.\r\n     */\r\n    AppRouter.prototype.reset = function () {\r\n        _super.prototype.reset.call(this);\r\n        this.maxInstructionCount = 10;\r\n        if (!this._queue) {\r\n            this._queue = [];\r\n        }\r\n        else {\r\n            this._queue.length = 0;\r\n        }\r\n    };\r\n    /**\r\n     * Loads the specified URL.\r\n     *\r\n     * @param url The URL fragment to load.\r\n     */\r\n    AppRouter.prototype.loadUrl = function (url) {\r\n        var _this = this;\r\n        return this\r\n            ._createNavigationInstruction(url)\r\n            .then(function (instruction) { return _this._queueInstruction(instruction); })\r\n            .catch(function (error) {\r\n            logger.error(error);\r\n            restorePreviousLocation(_this);\r\n        });\r\n    };\r\n    /**\r\n     * Registers a viewPort to be used as a rendering target for activated routes.\r\n     *\r\n     * @param viewPort The viewPort. This is typically a <router-view/> element in Aurelia default impl\r\n     * @param name The name of the viewPort. 'default' if unspecified.\r\n     */\r\n    AppRouter.prototype.registerViewPort = function (viewPort, name) {\r\n        var _this = this;\r\n        // having strong typing without changing public API\r\n        var $viewPort = viewPort;\r\n        _super.prototype.registerViewPort.call(this, $viewPort, name);\r\n        // beside adding viewport to the registry of this instance\r\n        // AppRouter also configure routing/history to start routing functionality\r\n        // There are situation where there are more than 1 <router-view/> element at root view\r\n        // in that case, still only activate once via the following guard\r\n        if (!this.isActive) {\r\n            var viewModel_1 = this._findViewModel($viewPort);\r\n            if ('configureRouter' in viewModel_1) {\r\n                // If there are more than one <router-view/> element at root view\r\n                // use this flag to guard against configure method being invoked multiple times\r\n                // this flag is set inside method configure\r\n                if (!this.isConfigured) {\r\n                    // replace the real resolve with a noop to guarantee that any action in base class Router\r\n                    // won't resolve the configurePromise prematurely\r\n                    var resolveConfiguredPromise_1 = this._resolveConfiguredPromise;\r\n                    this._resolveConfiguredPromise = function () { };\r\n                    return this\r\n                        .configure(function (config) {\r\n                        return Promise\r\n                            .resolve(viewModel_1.configureRouter(config, _this))\r\n                            // an issue with configure interface. Should be fixed there\r\n                            // todo: fix this via configure interface in router\r\n                            .then(function () { return config; });\r\n                    })\r\n                        .then(function () {\r\n                        _this.activate();\r\n                        resolveConfiguredPromise_1();\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                this.activate();\r\n            }\r\n        }\r\n        // when a viewport is added dynamically to a root view that is already activated\r\n        // just process the navigation instruction\r\n        else {\r\n            this._dequeueInstruction();\r\n        }\r\n        return Promise.resolve();\r\n    };\r\n    /**\r\n     * Activates the router. This instructs the router to begin listening for history changes and processing instructions.\r\n     *\r\n     * @params options The set of options to activate the router with.\r\n     */\r\n    AppRouter.prototype.activate = function (options) {\r\n        if (this.isActive) {\r\n            return;\r\n        }\r\n        this.isActive = true;\r\n        // route handler property is responsible for handling url change\r\n        // the interface of aurelia-history isn't clear on this perspective\r\n        this.options = Object.assign({ routeHandler: this.loadUrl.bind(this) }, this.options, options);\r\n        this.history.activate(this.options);\r\n        this._dequeueInstruction();\r\n    };\r\n    /**\r\n     * Deactivates the router.\r\n     */\r\n    AppRouter.prototype.deactivate = function () {\r\n        this.isActive = false;\r\n        this.history.deactivate();\r\n    };\r\n    /**@internal */\r\n    AppRouter.prototype._queueInstruction = function (instruction) {\r\n        var _this = this;\r\n        return new Promise(function (resolve) {\r\n            instruction.resolve = resolve;\r\n            _this._queue.unshift(instruction);\r\n            _this._dequeueInstruction();\r\n        });\r\n    };\r\n    /**@internal */\r\n    AppRouter.prototype._dequeueInstruction = function (instructionCount) {\r\n        var _this = this;\r\n        if (instructionCount === void 0) { instructionCount = 0; }\r\n        return Promise.resolve().then(function () {\r\n            if (_this.isNavigating && !instructionCount) {\r\n                // ts complains about inconsistent returns without void 0\r\n                return void 0;\r\n            }\r\n            var instruction = _this._queue.shift();\r\n            _this._queue.length = 0;\r\n            if (!instruction) {\r\n                // ts complains about inconsistent returns without void 0\r\n                return void 0;\r\n            }\r\n            _this.isNavigating = true;\r\n            var navtracker = _this.history.getState('NavigationTracker');\r\n            var currentNavTracker = _this.currentNavigationTracker;\r\n            if (!navtracker && !currentNavTracker) {\r\n                _this.isNavigatingFirst = true;\r\n                _this.isNavigatingNew = true;\r\n            }\r\n            else if (!navtracker) {\r\n                _this.isNavigatingNew = true;\r\n            }\r\n            else if (!currentNavTracker) {\r\n                _this.isNavigatingRefresh = true;\r\n            }\r\n            else if (currentNavTracker < navtracker) {\r\n                _this.isNavigatingForward = true;\r\n            }\r\n            else if (currentNavTracker > navtracker) {\r\n                _this.isNavigatingBack = true;\r\n            }\r\n            if (!navtracker) {\r\n                navtracker = Date.now();\r\n                _this.history.setState('NavigationTracker', navtracker);\r\n            }\r\n            _this.currentNavigationTracker = navtracker;\r\n            instruction.previousInstruction = _this.currentInstruction;\r\n            var maxInstructionCount = _this.maxInstructionCount;\r\n            if (!instructionCount) {\r\n                _this.events.publish(\"router:navigation:processing\" /* Processing */, { instruction: instruction });\r\n            }\r\n            else if (instructionCount === maxInstructionCount - 1) {\r\n                logger.error(instructionCount + 1 + \" navigation instructions have been attempted without success. Restoring last known good location.\");\r\n                restorePreviousLocation(_this);\r\n                return _this._dequeueInstruction(instructionCount + 1);\r\n            }\r\n            else if (instructionCount > maxInstructionCount) {\r\n                throw new Error('Maximum navigation attempts exceeded. Giving up.');\r\n            }\r\n            var pipeline = _this.pipelineProvider.createPipeline(!_this.couldDeactivate);\r\n            return pipeline\r\n                .run(instruction)\r\n                .then(function (result) { return processResult(instruction, result, instructionCount, _this); })\r\n                .catch(function (error) {\r\n                return { output: error instanceof Error ? error : new Error(error) };\r\n            })\r\n                .then(function (result) { return resolveInstruction(instruction, result, !!instructionCount, _this); });\r\n        });\r\n    };\r\n    /**@internal */\r\n    AppRouter.prototype._findViewModel = function (viewPort) {\r\n        if (this.container.viewModel) {\r\n            return this.container.viewModel;\r\n        }\r\n        if (viewPort.container) {\r\n            var container = viewPort.container;\r\n            while (container) {\r\n                if (container.viewModel) {\r\n                    this.container.viewModel = container.viewModel;\r\n                    return container.viewModel;\r\n                }\r\n                container = container.parent;\r\n            }\r\n        }\r\n        return undefined;\r\n    };\r\n    return AppRouter;\r\n}(Router));\r\nvar processResult = function (instruction, result, instructionCount, router) {\r\n    if (!(result && 'completed' in result && 'output' in result)) {\r\n        result = result || {};\r\n        result.output = new Error(\"Expected router pipeline to return a navigation result, but got [\" + JSON.stringify(result) + \"] instead.\");\r\n    }\r\n    var finalResult = null;\r\n    var navigationCommandResult = null;\r\n    if (isNavigationCommand(result.output)) {\r\n        navigationCommandResult = result.output.navigate(router);\r\n    }\r\n    else {\r\n        finalResult = result;\r\n        if (!result.completed) {\r\n            if (result.output instanceof Error) {\r\n                logger.error(result.output.toString());\r\n            }\r\n            restorePreviousLocation(router);\r\n        }\r\n    }\r\n    return Promise.resolve(navigationCommandResult)\r\n        .then(function (_) { return router._dequeueInstruction(instructionCount + 1); })\r\n        .then(function (innerResult) { return finalResult || innerResult || result; });\r\n};\r\nvar resolveInstruction = function (instruction, result, isInnerInstruction, router) {\r\n    instruction.resolve(result);\r\n    var eventAggregator = router.events;\r\n    var eventArgs = { instruction: instruction, result: result };\r\n    if (!isInnerInstruction) {\r\n        router.isNavigating = false;\r\n        router.isExplicitNavigation = false;\r\n        router.isExplicitNavigationBack = false;\r\n        router.isNavigatingFirst = false;\r\n        router.isNavigatingNew = false;\r\n        router.isNavigatingRefresh = false;\r\n        router.isNavigatingForward = false;\r\n        router.isNavigatingBack = false;\r\n        router.couldDeactivate = false;\r\n        var eventName = void 0;\r\n        if (result.output instanceof Error) {\r\n            eventName = \"router:navigation:error\" /* Error */;\r\n        }\r\n        else if (!result.completed) {\r\n            eventName = \"router:navigation:canceled\" /* Canceled */;\r\n        }\r\n        else {\r\n            var queryString = instruction.queryString ? ('?' + instruction.queryString) : '';\r\n            router.history.previousLocation = instruction.fragment + queryString;\r\n            eventName = \"router:navigation:success\" /* Success */;\r\n        }\r\n        eventAggregator.publish(eventName, eventArgs);\r\n        eventAggregator.publish(\"router:navigation:complete\" /* Complete */, eventArgs);\r\n    }\r\n    else {\r\n        eventAggregator.publish(\"router:navigation:child:complete\" /* ChildComplete */, eventArgs);\r\n    }\r\n    return result;\r\n};\r\nvar restorePreviousLocation = function (router) {\r\n    var previousLocation = router.history.previousLocation;\r\n    if (previousLocation) {\r\n        router.navigate(previousLocation, { trigger: false, replace: true });\r\n    }\r\n    else if (router.fallbackRoute) {\r\n        router.navigate(router.fallbackRoute, { trigger: true, replace: true });\r\n    }\r\n    else {\r\n        logger.error('Router navigation failed, and no previous location or fallbackRoute could be restored.');\r\n    }\r\n};\n\n/**\r\n* The status of a Pipeline.\r\n*/\r\nvar PipelineStatus;\r\n(function (PipelineStatus) {\r\n    PipelineStatus[\"Completed\"] = \"completed\";\r\n    PipelineStatus[\"Canceled\"] = \"canceled\";\r\n    PipelineStatus[\"Rejected\"] = \"rejected\";\r\n    PipelineStatus[\"Running\"] = \"running\";\r\n})(PipelineStatus || (PipelineStatus = {}));\n\n/**\r\n * A list of known router events used by the Aurelia router\r\n * to signal the pipeline has come to a certain state\r\n */\r\n// const enum is preserved in tsconfig\r\nvar RouterEvent;\r\n(function (RouterEvent) {\r\n    RouterEvent[\"Processing\"] = \"router:navigation:processing\";\r\n    RouterEvent[\"Error\"] = \"router:navigation:error\";\r\n    RouterEvent[\"Canceled\"] = \"router:navigation:canceled\";\r\n    RouterEvent[\"Complete\"] = \"router:navigation:complete\";\r\n    RouterEvent[\"Success\"] = \"router:navigation:success\";\r\n    RouterEvent[\"ChildComplete\"] = \"router:navigation:child:complete\";\r\n})(RouterEvent || (RouterEvent = {}));\n\n/**\r\n * Available pipeline slot names to insert interceptor into router pipeline\r\n */\r\n// const enum is preserved in tsconfig\r\nvar PipelineSlotName;\r\n(function (PipelineSlotName) {\r\n    /**\r\n     * Authorization slot. Invoked early in the pipeline,\r\n     * before `canActivate` hook of incoming route\r\n     */\r\n    PipelineSlotName[\"Authorize\"] = \"authorize\";\r\n    /**\r\n     * Pre-activation slot. Invoked early in the pipeline,\r\n     * Invoked timing:\r\n     *   - after Authorization slot\r\n     *   - after canActivate hook on new view model\r\n     *   - before deactivate hook on old view model\r\n     *   - before activate hook on new view model\r\n     */\r\n    PipelineSlotName[\"PreActivate\"] = \"preActivate\";\r\n    /**\r\n     * Pre-render slot. Invoked later in the pipeline\r\n     * Invokcation timing:\r\n     *   - after activate hook on new view model\r\n     *   - before commit step on new navigation instruction\r\n     */\r\n    PipelineSlotName[\"PreRender\"] = \"preRender\";\r\n    /**\r\n     * Post-render slot. Invoked last in the pipeline\r\n     */\r\n    PipelineSlotName[\"PostRender\"] = \"postRender\";\r\n})(PipelineSlotName || (PipelineSlotName = {}));\n\nexport { ActivateNextStep, AppRouter, BuildNavigationPlanStep, CanActivateNextStep, CanDeactivatePreviousStep, CommitChangesStep, DeactivatePreviousStep, LoadRouteStep, NavModel, NavigationInstruction, Pipeline, PipelineProvider, PipelineSlotName, PipelineStatus, Redirect, RedirectToRoute, RouteLoader, Router, RouterConfiguration, RouterEvent, activationStrategy, isNavigationCommand };\n//# sourceMappingURL=aurelia-router.js.map\n"],"sourceRoot":""}