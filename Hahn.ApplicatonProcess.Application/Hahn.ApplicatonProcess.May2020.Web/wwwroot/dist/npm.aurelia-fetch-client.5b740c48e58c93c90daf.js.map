{"version":3,"sources":["webpack:///./node_modules/aurelia-fetch-client/dist/native-modules/aurelia-fetch-client.js"],"names":[],"mappings":";;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA4C;;AAE5C;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uCAAuC;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,QAAQ,oDAAQ,8DAA8D,EAAE;AAC/I;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,+EAA+E,2BAA2B;AAC1G,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iBAAiB,EAAE;AAC5C,qCAAqC,8BAA8B,EAAE;AACrE,qCAAqC,4EAA4E,EAAE;AACnH;AACA,2CAA2C,uBAAuB;AAClE,2CAA2C,2BAA2B;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oDAAoD,EAAE;AACxG;AACA;AACA,6EAA6E,oDAAoD,EAAE;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,aAAa;AAC/C,8CAA8C,aAAa,YAAY,EAAE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,oBAAoB,+CAAG,4DAA4D,kCAAkC;AACrH,gCAAgC,QAAQ,+CAAG,sBAAsB,EAAE;AACnE;AACA;AACA;AACA;AACA;AACA,oBAAoB,+CAAG,6DAA6D,kCAAkC;AACtH,gCAAgC,QAAQ,+CAAG,sBAAsB,EAAE;AACnE;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,gGAAgG,EAAE,mDAAmD,6FAA6F,EAAE;AACnT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsF","file":"npm.aurelia-fetch-client.5b740c48e58c93c90daf.js","sourcesContent":["import { PLATFORM, DOM } from 'aurelia-pal';\n\nfunction json(body, replacer) {\r\n    return JSON.stringify((body !== undefined ? body : {}), replacer);\r\n}\n\nvar retryStrategy = {\r\n    fixed: 0,\r\n    incremental: 1,\r\n    exponential: 2,\r\n    random: 3\r\n};\r\nvar defaultRetryConfig = {\r\n    maxRetries: 3,\r\n    interval: 1000,\r\n    strategy: retryStrategy.fixed\r\n};\r\nvar RetryInterceptor = (function () {\r\n    function RetryInterceptor(retryConfig) {\r\n        this.retryConfig = Object.assign({}, defaultRetryConfig, retryConfig || {});\r\n        if (this.retryConfig.strategy === retryStrategy.exponential &&\r\n            this.retryConfig.interval <= 1000) {\r\n            throw new Error('An interval less than or equal to 1 second is not allowed when using the exponential retry strategy');\r\n        }\r\n    }\r\n    RetryInterceptor.prototype.request = function (request) {\r\n        var $r = request;\r\n        if (!$r.retryConfig) {\r\n            $r.retryConfig = Object.assign({}, this.retryConfig);\r\n            $r.retryConfig.counter = 0;\r\n        }\r\n        $r.retryConfig.requestClone = request.clone();\r\n        return request;\r\n    };\r\n    RetryInterceptor.prototype.response = function (response, request) {\r\n        delete request.retryConfig;\r\n        return response;\r\n    };\r\n    RetryInterceptor.prototype.responseError = function (error, request, httpClient) {\r\n        var retryConfig = request.retryConfig;\r\n        var requestClone = retryConfig.requestClone;\r\n        return Promise.resolve().then(function () {\r\n            if (retryConfig.counter < retryConfig.maxRetries) {\r\n                var result = retryConfig.doRetry ? retryConfig.doRetry(error, request) : true;\r\n                return Promise.resolve(result).then(function (doRetry) {\r\n                    if (doRetry) {\r\n                        retryConfig.counter++;\r\n                        return new Promise(function (resolve) { return PLATFORM.global.setTimeout(resolve, calculateDelay(retryConfig) || 0); })\r\n                            .then(function () {\r\n                            var newRequest = requestClone.clone();\r\n                            if (typeof (retryConfig.beforeRetry) === 'function') {\r\n                                return retryConfig.beforeRetry(newRequest, httpClient);\r\n                            }\r\n                            return newRequest;\r\n                        })\r\n                            .then(function (newRequest) {\r\n                            return httpClient.fetch(Object.assign(newRequest, { retryConfig: retryConfig }));\r\n                        });\r\n                    }\r\n                    delete request.retryConfig;\r\n                    throw error;\r\n                });\r\n            }\r\n            delete request.retryConfig;\r\n            throw error;\r\n        });\r\n    };\r\n    return RetryInterceptor;\r\n}());\r\nfunction calculateDelay(retryConfig) {\r\n    var interval = retryConfig.interval, strategy = retryConfig.strategy, minRandomInterval = retryConfig.minRandomInterval, maxRandomInterval = retryConfig.maxRandomInterval, counter = retryConfig.counter;\r\n    if (typeof (strategy) === 'function') {\r\n        return retryConfig.strategy(counter);\r\n    }\r\n    switch (strategy) {\r\n        case (retryStrategy.fixed):\r\n            return retryStrategies[retryStrategy.fixed](interval);\r\n        case (retryStrategy.incremental):\r\n            return retryStrategies[retryStrategy.incremental](counter, interval);\r\n        case (retryStrategy.exponential):\r\n            return retryStrategies[retryStrategy.exponential](counter, interval);\r\n        case (retryStrategy.random):\r\n            return retryStrategies[retryStrategy.random](counter, interval, minRandomInterval, maxRandomInterval);\r\n        default:\r\n            throw new Error('Unrecognized retry strategy');\r\n    }\r\n}\r\nvar retryStrategies = [\r\n    function (interval) { return interval; },\r\n    function (retryCount, interval) { return interval * retryCount; },\r\n    function (retryCount, interval) { return retryCount === 1 ? interval : Math.pow(interval, retryCount) / 1000; },\r\n    function (retryCount, interval, minRandomInterval, maxRandomInterval) {\r\n        if (minRandomInterval === void 0) { minRandomInterval = 0; }\r\n        if (maxRandomInterval === void 0) { maxRandomInterval = 60000; }\r\n        return Math.random() * (maxRandomInterval - minRandomInterval) + minRandomInterval;\r\n    }\r\n];\n\nvar HttpClientConfiguration = (function () {\r\n    function HttpClientConfiguration() {\r\n        this.baseUrl = '';\r\n        this.defaults = {};\r\n        this.interceptors = [];\r\n    }\r\n    HttpClientConfiguration.prototype.withBaseUrl = function (baseUrl) {\r\n        this.baseUrl = baseUrl;\r\n        return this;\r\n    };\r\n    HttpClientConfiguration.prototype.withDefaults = function (defaults) {\r\n        this.defaults = defaults;\r\n        return this;\r\n    };\r\n    HttpClientConfiguration.prototype.withInterceptor = function (interceptor) {\r\n        this.interceptors.push(interceptor);\r\n        return this;\r\n    };\r\n    HttpClientConfiguration.prototype.useStandardConfiguration = function () {\r\n        var standardConfig = { credentials: 'same-origin' };\r\n        Object.assign(this.defaults, standardConfig, this.defaults);\r\n        return this.rejectErrorResponses();\r\n    };\r\n    HttpClientConfiguration.prototype.rejectErrorResponses = function () {\r\n        return this.withInterceptor({ response: rejectOnError });\r\n    };\r\n    HttpClientConfiguration.prototype.withRetry = function (config) {\r\n        var interceptor = new RetryInterceptor(config);\r\n        return this.withInterceptor(interceptor);\r\n    };\r\n    return HttpClientConfiguration;\r\n}());\r\nfunction rejectOnError(response) {\r\n    if (!response.ok) {\r\n        throw response;\r\n    }\r\n    return response;\r\n}\n\nvar HttpClient = (function () {\r\n    function HttpClient() {\r\n        this.activeRequestCount = 0;\r\n        this.isRequesting = false;\r\n        this.isConfigured = false;\r\n        this.baseUrl = '';\r\n        this.defaults = null;\r\n        this.interceptors = [];\r\n        if (typeof fetch === 'undefined') {\r\n            throw new Error('HttpClient requires a Fetch API implementation, but the current environment doesn\\'t support it. You may need to load a polyfill such as https://github.com/github/fetch');\r\n        }\r\n    }\r\n    HttpClient.prototype.configure = function (config) {\r\n        var normalizedConfig;\r\n        if (typeof config === 'object') {\r\n            normalizedConfig = { defaults: config };\r\n        }\r\n        else if (typeof config === 'function') {\r\n            normalizedConfig = new HttpClientConfiguration();\r\n            normalizedConfig.baseUrl = this.baseUrl;\r\n            normalizedConfig.defaults = Object.assign({}, this.defaults);\r\n            normalizedConfig.interceptors = this.interceptors;\r\n            var c = config(normalizedConfig);\r\n            if (HttpClientConfiguration.prototype.isPrototypeOf(c)) {\r\n                normalizedConfig = c;\r\n            }\r\n        }\r\n        else {\r\n            throw new Error('invalid config');\r\n        }\r\n        var defaults = normalizedConfig.defaults;\r\n        if (defaults && Headers.prototype.isPrototypeOf(defaults.headers)) {\r\n            throw new Error('Default headers must be a plain object.');\r\n        }\r\n        var interceptors = normalizedConfig.interceptors;\r\n        if (interceptors && interceptors.length) {\r\n            if (interceptors.filter(function (x) { return RetryInterceptor.prototype.isPrototypeOf(x); }).length > 1) {\r\n                throw new Error('Only one RetryInterceptor is allowed.');\r\n            }\r\n            var retryInterceptorIndex = interceptors.findIndex(function (x) { return RetryInterceptor.prototype.isPrototypeOf(x); });\r\n            if (retryInterceptorIndex >= 0 && retryInterceptorIndex !== interceptors.length - 1) {\r\n                throw new Error('The retry interceptor must be the last interceptor defined.');\r\n            }\r\n        }\r\n        this.baseUrl = normalizedConfig.baseUrl;\r\n        this.defaults = defaults;\r\n        this.interceptors = normalizedConfig.interceptors || [];\r\n        this.isConfigured = true;\r\n        return this;\r\n    };\r\n    HttpClient.prototype.fetch = function (input, init) {\r\n        var _this = this;\r\n        trackRequestStart(this);\r\n        var request = this.buildRequest(input, init);\r\n        return processRequest(request, this.interceptors, this).then(function (result) {\r\n            var response = null;\r\n            if (Response.prototype.isPrototypeOf(result)) {\r\n                response = Promise.resolve(result);\r\n            }\r\n            else if (Request.prototype.isPrototypeOf(result)) {\r\n                request = result;\r\n                response = fetch(result);\r\n            }\r\n            else {\r\n                throw new Error(\"An invalid result was returned by the interceptor chain. Expected a Request or Response instance, but got [\" + result + \"]\");\r\n            }\r\n            return processResponse(response, _this.interceptors, request, _this);\r\n        })\r\n            .then(function (result) {\r\n            if (Request.prototype.isPrototypeOf(result)) {\r\n                return _this.fetch(result);\r\n            }\r\n            return result;\r\n        })\r\n            .then(function (result) {\r\n            trackRequestEnd(_this);\r\n            return result;\r\n        }, function (error) {\r\n            trackRequestEnd(_this);\r\n            throw error;\r\n        });\r\n    };\r\n    HttpClient.prototype.buildRequest = function (input, init) {\r\n        var defaults = this.defaults || {};\r\n        var request;\r\n        var body;\r\n        var requestContentType;\r\n        var parsedDefaultHeaders = parseHeaderValues(defaults.headers);\r\n        if (Request.prototype.isPrototypeOf(input)) {\r\n            request = input;\r\n            requestContentType = new Headers(request.headers).get('Content-Type');\r\n        }\r\n        else {\r\n            if (!init) {\r\n                init = {};\r\n            }\r\n            body = init.body;\r\n            var bodyObj = body ? { body: body } : null;\r\n            var requestInit = Object.assign({}, defaults, { headers: {} }, init, bodyObj);\r\n            requestContentType = new Headers(requestInit.headers).get('Content-Type');\r\n            request = new Request(getRequestUrl(this.baseUrl, input), requestInit);\r\n        }\r\n        if (!requestContentType) {\r\n            if (new Headers(parsedDefaultHeaders).has('content-type')) {\r\n                request.headers.set('Content-Type', new Headers(parsedDefaultHeaders).get('content-type'));\r\n            }\r\n            else if (body && isJSON(body)) {\r\n                request.headers.set('Content-Type', 'application/json');\r\n            }\r\n        }\r\n        setDefaultHeaders(request.headers, parsedDefaultHeaders);\r\n        if (body && Blob.prototype.isPrototypeOf(body) && body.type) {\r\n            request.headers.set('Content-Type', body.type);\r\n        }\r\n        return request;\r\n    };\r\n    HttpClient.prototype.get = function (input, init) {\r\n        return this.fetch(input, init);\r\n    };\r\n    HttpClient.prototype.post = function (input, body, init) {\r\n        return callFetch(this, input, body, init, 'POST');\r\n    };\r\n    HttpClient.prototype.put = function (input, body, init) {\r\n        return callFetch(this, input, body, init, 'PUT');\r\n    };\r\n    HttpClient.prototype.patch = function (input, body, init) {\r\n        return callFetch(this, input, body, init, 'PATCH');\r\n    };\r\n    HttpClient.prototype.delete = function (input, body, init) {\r\n        return callFetch(this, input, body, init, 'DELETE');\r\n    };\r\n    return HttpClient;\r\n}());\r\nvar absoluteUrlRegexp = /^([a-z][a-z0-9+\\-.]*:)?\\/\\//i;\r\nfunction trackRequestStart(client) {\r\n    client.isRequesting = !!(++client.activeRequestCount);\r\n    if (client.isRequesting) {\r\n        var evt_1 = DOM.createCustomEvent('aurelia-fetch-client-request-started', { bubbles: true, cancelable: true });\r\n        setTimeout(function () { return DOM.dispatchEvent(evt_1); }, 1);\r\n    }\r\n}\r\nfunction trackRequestEnd(client) {\r\n    client.isRequesting = !!(--client.activeRequestCount);\r\n    if (!client.isRequesting) {\r\n        var evt_2 = DOM.createCustomEvent('aurelia-fetch-client-requests-drained', { bubbles: true, cancelable: true });\r\n        setTimeout(function () { return DOM.dispatchEvent(evt_2); }, 1);\r\n    }\r\n}\r\nfunction parseHeaderValues(headers) {\r\n    var parsedHeaders = {};\r\n    for (var name_1 in headers || {}) {\r\n        if (headers.hasOwnProperty(name_1)) {\r\n            parsedHeaders[name_1] = (typeof headers[name_1] === 'function') ? headers[name_1]() : headers[name_1];\r\n        }\r\n    }\r\n    return parsedHeaders;\r\n}\r\nfunction getRequestUrl(baseUrl, url) {\r\n    if (absoluteUrlRegexp.test(url)) {\r\n        return url;\r\n    }\r\n    return (baseUrl || '') + url;\r\n}\r\nfunction setDefaultHeaders(headers, defaultHeaders) {\r\n    for (var name_2 in defaultHeaders || {}) {\r\n        if (defaultHeaders.hasOwnProperty(name_2) && !headers.has(name_2)) {\r\n            headers.set(name_2, defaultHeaders[name_2]);\r\n        }\r\n    }\r\n}\r\nfunction processRequest(request, interceptors, http) {\r\n    return applyInterceptors(request, interceptors, 'request', 'requestError', http);\r\n}\r\nfunction processResponse(response, interceptors, request, http) {\r\n    return applyInterceptors(response, interceptors, 'response', 'responseError', request, http);\r\n}\r\nfunction applyInterceptors(input, interceptors, successName, errorName) {\r\n    var interceptorArgs = [];\r\n    for (var _i = 4; _i < arguments.length; _i++) {\r\n        interceptorArgs[_i - 4] = arguments[_i];\r\n    }\r\n    return (interceptors || [])\r\n        .reduce(function (chain, interceptor) {\r\n        var successHandler = interceptor[successName];\r\n        var errorHandler = interceptor[errorName];\r\n        return chain.then(successHandler && (function (value) { return successHandler.call.apply(successHandler, [interceptor, value].concat(interceptorArgs)); }) || identity, errorHandler && (function (reason) { return errorHandler.call.apply(errorHandler, [interceptor, reason].concat(interceptorArgs)); }) || thrower);\r\n    }, Promise.resolve(input));\r\n}\r\nfunction isJSON(str) {\r\n    try {\r\n        JSON.parse(str);\r\n    }\r\n    catch (err) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nfunction identity(x) {\r\n    return x;\r\n}\r\nfunction thrower(x) {\r\n    throw x;\r\n}\r\nfunction callFetch(client, input, body, init, method) {\r\n    if (!init) {\r\n        init = {};\r\n    }\r\n    init.method = method;\r\n    if (body) {\r\n        init.body = body;\r\n    }\r\n    return client.fetch(input, init);\r\n}\n\nexport { json, retryStrategy, RetryInterceptor, HttpClientConfiguration, HttpClient };\n"],"sourceRoot":""}