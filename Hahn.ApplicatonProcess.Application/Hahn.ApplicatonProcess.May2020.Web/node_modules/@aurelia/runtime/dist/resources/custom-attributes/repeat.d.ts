import { ForOfStatement } from '../../binding/ast';
import { INode, IRenderLocation } from '../../dom';
import { LifecycleFlags as LF } from '../../flags';
import { ISyntheticView, IViewFactory, ICustomAttributeController, IRenderableController, ICustomAttributeViewModel } from '../../lifecycle';
import { ILifecycleTask } from '../../lifecycle-task';
import { CollectionObserver, IndexMap, IObservedArray, ObservedCollection } from '../../observation';
declare type Items<C extends ObservedCollection = IObservedArray> = C | undefined;
export declare class Repeat<C extends ObservedCollection = IObservedArray, T extends INode = INode> implements ICustomAttributeViewModel<T> {
    location: IRenderLocation<T>;
    renderable: IRenderableController<T>;
    factory: IViewFactory<T>;
    readonly id: number;
    hasPendingInstanceMutation: boolean;
    observer?: CollectionObserver;
    views: ISyntheticView<T>[];
    key?: string;
    forOf: ForOfStatement;
    local: string;
    readonly $controller: ICustomAttributeController<T, this>;
    private task;
    items: Items<C>;
    private normalizedItems?;
    constructor(location: IRenderLocation<T>, renderable: IRenderableController<T>, factory: IViewFactory<T>);
    beforeBind(flags: LF): ILifecycleTask;
    beforeAttach(flags: LF): void;
    beforeDetach(flags: LF): void;
    beforeUnbind(flags: LF): ILifecycleTask;
    itemsChanged(flags: LF): void;
    handleCollectionChange(indexMap: IndexMap | undefined, flags: LF): void;
    private processViewsKeyed;
    private checkCollectionObserver;
    private normalizeToArray;
    private detachViewsByRange;
    private unbindAndRemoveViewsByRange;
    private detachViewsByKey;
    private unbindAndRemoveViewsByKey;
    private createAndBindAllViews;
    private createAndBindNewViewsByKey;
    private attachViews;
    private attachViewsKeyed;
    private sortViewsByKey;
}
export {};
//# sourceMappingURL=repeat.d.ts.map